<!DOCTYPE html>
<html lang="en">

<head>


    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>async - Documentation</title>

    <link rel="icon" href="favicon.ico?v=2">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/bootstrap/3.3.6/css/bootstrap.min.css">

    <link rel="stylesheet" href="styles/prettify-tomorrow.css">

    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700">
    <link rel="stylesheet" href="styles/jsdoc-default.css">

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/ionicons/2.0.1/css/ionicons.min.css">
</head>

<body>

    <div class="navbar navbar-default navbar-fixed-top">
        <div class="navbar-header">
            <a class="navbar-brand" href="#">
                <img src="img/async-logo.svg" alt="Async.js">
            </a>
        </div>
        <ul class="nav navbar-nav">
            <li id="version-dropdown" class="dropdown">
                <a href="#" class="dropdown-toggle vertically-centered" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">v2.6.0 <span class="caret"></span>
      </a>
                <ul class="dropdown-menu">
                    <li><a href="docs.html">v2.6.0</a></li>
                    <li>
                        <a href="https://github.com/caolan/async/blob/v1.5.2/README.md">v1.5.x</a>
                    </li>
                </ul>
            </li>
            <li><a href="./index.html">Home</a></li>
            <li><a href="./docs.html">Docs</a></li>
            <li><a href="https://github.com/caolan/async/blob/master/CHANGELOG.md">Changelog</a></li>
            <li><a href="https://github.com/caolan/async"><i class="ion-social-github" aria-hidden="true"></i></a></li>
        </ul>
        <ul class="nav navbar-nav navbar-right">
            <form class="navbar-form navbar-left" role="search">
                <div class="form-group">
                    <input type="text" class="form-control typeahead" id="doc-search" placeholder="Search" autofocus>
                </div>
            </form>
        </ul>
    </div>


    <input type="checkbox" id="nav-trigger" class="nav-trigger">
    <label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

    <label for="nav-trigger" class="overlay"></label>

    <div id="main">
        <div id="main-container" data-spy="scroll" data-target="#toc" data-offset="50">

            <h1 class="page-title">async</h1>
            <section>
                <header>
                </header>
                <article>
                    <div class="container-overview">
                        <div class="description">
                            <p>Async 是一个实用程序模块，它为使用异步 JavaScript 提供了直接、 强大的函数。尽管最初设计用于与 <a href="http://nodejs.org">Node.js</a> 一起使用， 使用 <code>npm install --save async</code> 进行安装。 它也可以直接在浏览器中使用。</p>
                        </div>
                        <dl class="details">
                            <dt class="tag-source">Source:</dt>
                            <dd class="tag-source">
                                <ul class="dummy">
                                    <li>
                                        <a href="index.js.html">index.js</a>, <a href="index.js.html#line40">line 40</a>
                                    </li>
                                </ul>
                            </dd>
                            <dt class="tag-see">See:</dt>
                            <dd class="tag-see">
                                <ul>
                                    <li><a href="global.html">AsyncFunction </a></li>
                                </ul>
                            </dd>
                        </dl>
                    </div>
                </article>
            </section>
            <h1 class="page-title" id="collections">Collections</h1>
            <section>
                <header>
                </header>
                <article>
                    <div class="container-overview">
                        <div class="description">
                            <p>用于操作集合的 <code>async</code> 函数集合，例如数组和对象。</p>
                        </div>
                        <dl class="details">
                            <dt class="tag-source">Source:</dt>
                            <dd class="tag-source">
                                <ul class="dummy">
                                    <li>
                                        <a href="index.js.html">index.js</a>, <a href="index.js.html#line50">line 50</a>
                                    </li>
                                </ul>
                            </dd>
                        </dl>
                    </div>
                    <h3 class="subsection-title">Methods</h3>
                    <h4 class="name" id="concat"><span class="type-signature">(static) </span>concat<span class="signature">(coll, iteratee, callback(err)<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source">
        <code>import concat from &apos;async/concat&apos;;</code></pre>
                        <p>将 <code>iteratee</code> 应用到 <code>coll</code> 中的每一项, 连接的结果。 返回连接后的列表。 <code>iteratee</code>s 被并行调用，结果在返回时被连接起来。不能保证结果数组以 <code>coll</code> 传递给 <code>iteratee</code> 函数的原始顺序返回。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项的函数， 结果为一个数组。使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback(err)</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>在所有的 <code>iteratee</code> 函数完成后， 或者发生错误时被调用的一个回调函数。结果是一个数组， 其中包含了 <code>iteratee</code> 函数的连接结果。使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.concat([&apos;dir1&apos;,&apos;dir2&apos;,&apos;dir3&apos;], fs.readdir, function(err, files) {
    // files 现在是给定的 3 个目录中存在的文件名的一个列表（list）
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="concat.js.html">concat.js</a>, <a href="concat.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="concatLimit"><span class="type-signature">(static) </span>concatLimit<span class="signature">(coll, limit, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import concatLimit from &apos;async/concatLimit&apos;;</code></pre>
                        <p>与 <a href="#concat"><code>concat</code></a> 相同，但只能同时运行最多 <code>limit</code> 个的异步操作。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p>同时运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项的函数， 结果为一个数组. 使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>在所有的 <code>iteratee</code> 函数完成后， 或者发生错误时被调用的一个回调函数。结果是一个数组， 其中包含了 <code>iteratee</code> 函数的连接结果。使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="concatLimit.js.html">concatLimit.js</a>, <a href="concatLimit.js.html#line8">line 8</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#concat">async.concat</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="concatSeries"><span class="type-signature">(static) </span>concatSeries<span class="signature">(coll, iteratee, callback(err)<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import concatSeries from &apos;async/concatSeries&apos;;</code></pre>
                        <p>与 <a href="#concat"><code>concat</code></a> 相同，但每次只运行一个异步操作。「译者注：」也就说这个是按照传入顺序执行的，当然结果也就是顺序输出。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |

                                    <span class="param-type">Iterable</span> |

                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>

                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项的函数， 结果为一个数组. 使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback(err)</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>在所有的 <code>iteratee</code> 函数完成后， 或者发生错误时被调用的一个回调函数。结果是一个数组， 其中包含了 <code>iteratee</code> 函数的连接结果。使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="concatSeries.js.html">concatSeries.js</a>, <a href="concatSeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#concat">async.concat</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="detect"><span class="type-signature">(static) </span>detect<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import detect from &apos;async/detect&apos;;</code></pre>
                        <p>返回 <code>coll</code> 中的第一个通过 async 真实测试的值。<code>iteratee</code> 是并行应用的， 这意味着第一个返回 <code>true</code> 的迭代器将使用该结果触发探测（detect）<code>callback</code>。 这意味着结果可能不是通过能够通过测试的最初的 <code>coll</code> (按顺序)的第一个项目。 如果在原始的 <code>coll</code> 中顺序很重要，那么就看一下
                            <a href="#detectSeries"><code>detectSeries</code></a> 。
                        </p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>find</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>
                                        为 <code>coll</code> 中的每一项进行真实测试的函数。 迭代器的值为布尔值。 使用 (item, callback) 调用。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>

                                </td>
                                <td class="description last">
                                    <p>当任意一个迭代器返回 <code>true</code> ，或者所有的迭代器都执行完毕，亦或发生错的时候被调用的回调函数。 result 是数组中第一个通过真理测试的项，或者是没有通过的项时的 <code>undefined</code> 值。使用 (err, result)调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>

                    <pre class="prettyprint">
                        <code>async.detect([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath, callback) {
    fs.access(filePath, function(err) {
        callback(null, !err)
    });
}, function(err, result) {
    // 结果现在等于列表中的存在第一个文件
});
</code>
                    </pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="detect.js.html">detect.js</a>, <a href="detect.js.html#line7">line 7</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="detectLimit"><span class="type-signature">(static) </span>detectLimit<span class="signature">(coll, limit, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import detectLimit from &apos;async/detectLimit&apos;;</code></pre>
                        <p>跟 <a href="#detect"><code>detect</code></a> 一样，但是只能同时运行最多 <code>limit</code> 个异步操作。
                        </p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>findLimit</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p>同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>
                                        为 <code>coll</code> 中的每一项进行真实测试的函数。 迭代器的值为布尔值。 使用 (item, callback) 调用。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>

                                </td>
                                <td class="description last">
                                    <p>当任意一个迭代器返回 <code>true</code> ， 或者所有的迭代器都执行完毕，亦或发生错的时候被调用的回调函数。 result 是数组中第一个通过真理测试的项，或者是没有通过的项时的 <code>undefined</code> 值。 使用 (err, result)调用。
                                    </p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="detectLimit.js.html">detectLimit.js</a>, <a href="detectLimit.js.html#line7">line 7</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#detect">async.detect</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="detectSeries"><span class="type-signature">(static) </span>detectSeries<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import detectSeries from &apos;async/detectSeries&apos;;</code></pre>
                        <p>与 <a href="#detect"><code>detect</code></a> 相同。但同时只能运行一个异步操作。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>findSeries</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>

                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>
                                        为 <code>coll</code> 中的每一项进行真实测试的函数。 迭代器的值为布尔值。 使用 (item, callback) 调用。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>当任意一个迭代器返回 <code>true</code> ， 或者所有的迭代器都执行完毕，亦或发生错的时候被调用的回调函数。 result 是数组中第一个通过真理测试的项，或者是没有通过的项时的 <code>undefined</code> 值。 使用 (err, result)调用。
                                    </p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="detectSeries.js.html">detectSeries.js</a>, <a href="detectSeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#detect">async.detect</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="each"><span class="type-signature">(static) </span>each<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import each from &apos;async/each&apos;;</code></pre>
                        <p>
                            将函数<code>iteratee</code> 并行地应用于 <code>coll</code> 中的每一个项目。
                            <code>iteratee</code> 被从列表中调用，当它完成时调用回调。 如果 <code>iteratee</code> 将一个错误传递给它的 <code>callback</code>，则会立即使用错误对象调用主 <code>callback</code>(针对 <code>each</code> 函数)。
                        </p>
                        <p>
                            注意，由于该函数将 <code>iteratee</code> 应用于每个项目，因此不能保证迭代器函数将按顺序完成。
                        </p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>forEach</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>


                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用于 <code>coll</code> 中的每一项的异步函数。使用 (item, callback) 调用。数组的索引没有传递给迭代器。 如果你需要索引， use <code>eachOf</code>.</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。使用 (err) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>

                    <pre class="prettyprint"><code>// 假设 openFile 是一个文件名数组，saveFile 是一个用来保存文件的被修改内容的函数

async.each(openFiles, saveFile, function(err){
  // 如果任何保存产生了错误， err 就等于那个错误
});

// 假设 openFile 是一个文件名数组
async.each(openFiles, function(file, callback) {

    // 在这里执行文件上的操作。
    console.log(&apos;Processing file &apos; + file);

    if( file.length &gt; 32 ) {
      console.log(&apos;This file name is too long&apos;);
      callback(&apos;File name too long&apos;);
    } else {
      // 在这里处理文件
      console.log(&apos;File processed&apos;);
      callback();
    }
}, function(err) {
    // 如果任何文件处理产生了错误， err 就等于那个错误
    if( err ) {
      // 其中一个迭代产生了一个错误。
      // 所有的处理都将停止。
      console.log(&apos;A file failed to process&apos;);
    } else {
      console.log(&apos;All files have been processed successfully&apos;);
    }
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="each.js.html">each.js</a>, <a href="each.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="eachLimit"><span class="type-signature">(static) </span>eachLimit<span class="signature">(coll, limit, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import eachLimit from &apos;async/eachLimit&apos;;</code></pre>
                        <p>与 <a href="#each"><code>each</code></a> 一样，但是只能同时运行最多 limit 个异步操作。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>forEachLimit</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p> 同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项目的异步函数。数组的索引没有传递给迭代器。 如果你需要索引，请使用 <code>eachOfLimit</code>. 使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。使用 (err) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="eachLimit.js.html">eachLimit.js</a>, <a href="eachLimit.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#each">async.each</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="eachOf"><span class="type-signature">(static) </span>eachOf<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import eachOf from &apos;async/eachOf&apos;;</code></pre>
                        <p>跟 <a href="#each"><code>each</code></a> 一样，除了它将键(或索引)作为第二个参数传递给迭代器。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>forEachOf</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项的函数。 <code>key</code> 是当前项在数组中的索引，使用 (item, key, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。使用 (err) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>var obj = {dev: &quot;/dev.json&quot;, test: &quot;/test.json&quot;, prod: &quot;/prod.json&quot;};
var configs = {};

async.forEachOf(obj, function (value, key, callback) {
    fs.readFile(__dirname + value, &quot;utf8&quot;, function (err, data) {
        if (err) return callback(err);
        try {
            configs[key] = JSON.parse(data);
        } catch (e) {
            return callback(e);
        }
        callback();
    });
}, function (err) {
    if (err) console.error(err.message);
    // configs 现在是 JSON 数据的一个映射
    doSomethingWith(configs);
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="eachOf.js.html">eachOf.js</a>, <a href="eachOf.js.html#line37">line 37</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#each">async.each</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="eachOfLimit"><span class="type-signature">(static) </span>eachOfLimit<span class="signature">(coll, limit, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import eachOfLimit from &apos;async/eachOfLimit&apos;;</code></pre>
                        <p>与 <a href="#eachOf"><code>eachOf</code></a> 一样，但是只能同时运行最多 limit 个异步操作。
                        </p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>forEachOfLimit</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p> 同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用于 <code>coll</code> 中的每一项的异步函数。<code>key</code> 是当前项在数组中的索引，使用 (item, key, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。使用 (err) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="eachOfLimit.js.html">eachOfLimit.js</a>, <a href="eachOfLimit.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#eachOf">async.eachOf</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="eachOfSeries"><span class="type-signature">(static) </span>eachOfSeries<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import eachOfSeries from &apos;async/eachOfSeries&apos;;</code></pre>
                        <p>与 <a href="#eachOf"><code>eachOf</code></a> 一样，，但同时只能运行一个异步操作。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>forEachOfSeries</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项目的异步函数。使用 (item, key, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。使用 (err) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="eachOfSeries.js.html">eachOfSeries.js</a>, <a href="eachOfSeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#eachOf">async.eachOf</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="eachSeries"><span class="type-signature">(static) </span>eachSeries<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import eachSeries from &apos;async/eachSeries&apos;;</code></pre>
                        <p>与 <a href="#each"><code>each</code></a> 一样，但同时只能运行一个异步操作。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>forEachSeries</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>

                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用于 <code>coll</code> 中的每一项的异步函数。数组的索引没有传递给迭代器。 如果你需要索引， 请使用 <code>eachOfSeries</code>。 使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。使用 (err) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="eachSeries.js.html">eachSeries.js</a>, <a href="eachSeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#each">async.each</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="every"><span class="type-signature">(static) </span>every<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import every from &apos;async/every&apos;;</code></pre>
                        <p>如果 <code>coll</code> 中的每个元素都满足异步测试，那么返回 <code>true</code>。如果任何迭代器调用返回 <code>false</code>，则会立即调用主 <code>callback</code>。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>all</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个异步的真实测试，可以并行地应用到集合中的每一个项目。 结果为一个布尔值。 使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕时调用的回调函数。 result 是 <code>true</code> 或者 <code>false</code> ，这取决于异步测试的值。 使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.every([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath, callback) {
    fs.access(filePath, function(err) {
        callback(null, !err)
    });
}, function(err, result) {
    // 如果 result 为真，那么每个文件都存在
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="every.js.html">every.js</a>, <a href="every.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="everyLimit"><span class="type-signature">(static) </span>everyLimit<span class="signature">(coll, limit, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import everyLimit from &apos;async/everyLimit&apos;;</code></pre>
                        <p>与 <a href="#every"><code>every</code></a> 一样，但是只能同时运行最多 limit 个异步操作。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>allLimit</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p> 同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个异步的真实测试，可以并行地应用到集合中的每一个项目。结果为一个布尔值。使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕时调用的回调函数。result 是 <code>true</code> 或者 <code>false</code> ，这取决于异步测试的值。 使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="everyLimit.js.html">everyLimit.js</a>, <a href="everyLimit.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#every">async.every</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="everySeries"><span class="type-signature">(static) </span>everySeries<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import everySeries from &apos;async/everySeries&apos;;</code></pre>
                        <p>与 <a href="#every"><code>every</code></a> 一样，但同时只能运行一个异步操作。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>allSeries</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个异步的真实测试，被应用于集合中的每一个项目。结果为一个布尔值。 使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕时调用的回调函数。result 是 <code>true</code> 或者 <code>false</code> ，这取决于异步测试的值。 使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="everySeries.js.html">everySeries.js</a>, <a href="everySeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#every">async.every</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="filter"><span class="type-signature">(static) </span>filter<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import filter from &apos;async/filter&apos;;</code></pre>
                        <p>返回一个由 <code>coll</code> 中通过异步真实测试的项目构成的新数组。这个操作是并行执行的，但是结果数组和原来的顺序是一样的。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>select</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个真实测试，被应用于集合中的每一个项目。<code>iteratee</code> 有一个 <code>callback(err, truthValue)</code>，当迭代器执行完成后使用迭代器返回的布尔值作为参数调用这个回调函数。使用(item, callback)调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕时调用的回调函数。
                                        <code>iteratee</code> functions have finished. 使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.filter([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath, callback) {
    fs.access(filePath, function(err) {
        callback(null, !err)
    });
}, function(err, results) {
    // results 现在等于存在的文件的数组
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="filter.js.html">filter.js</a>, <a href="filter.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="filterLimit"><span class="type-signature">(static) </span>filterLimit<span class="signature">(coll, limit, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import filterLimit from &apos;async/filterLimit&apos;;</code></pre>
                        <p>与 <a href="#filter"><code>filter</code></a> 一样，但是只能同时运行最多 limit 个异步操作。
                        </p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>selectLimit</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p> 同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个真实测试，被应用于集合中的每一个项目。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕时调用的回调函数。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="filterLimit.js.html">filterLimit.js</a>, <a href="filterLimit.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#filter">async.filter</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="filterSeries"><span class="type-signature">(static) </span>filterSeries<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import filterSeries from &apos;async/filterSeries&apos;;</code></pre>
                        <p>与 <a href="#filter"><code>filter</code></a>一样，但同时只能运行一个异步操作。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>selectSeries</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个真实测试，被应用于集合中的每一个项目。 <code>iteratee</code> 有一个 <code>callback(err, truthValue)</code>，当迭代器执行完成后使用迭代器返回的布尔值作为参数调用这个回调函数。使用(item, callback)调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕时调用的回调函数。使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="filterSeries.js.html">filterSeries.js</a>, <a href="filterSeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#filter">async.filter</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="groupBy"><span class="type-signature">(static) </span>groupBy<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import groupBy from &apos;async/groupBy&apos;;</code></pre>
                        <p>返回一个新对象，其中每个值对应于一个来自 <code>coll</code> 项目所构成的数组，并返回了对应的键。 也就是说，对象的键对应于传递给 <code>iteratee</code> 回调的值。
                        </p>
                        <p>「译者注：」 本函数的作用是按照一定的规则对 <code>coll</code> 进行分组，每个分组为一个数组，数组与规则一一对应，并按照键值对的方式存储在一个对象中。</p>
                        <p>注意：由于该函数将 <code>iteratee</code> 并行地应用于每个项目，因此无法保证 <code>iteratee</code> 函数将按顺序完成。 但是， <code>result</code> 中的每个键的值的顺序将与原来的 <code>coll</code> 中的顺序相同。 对于对象，值将大致按照原始对象的键的顺序(但这可能在不同的 JavaScript 引擎中有所不同)。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项目的异步函数。迭代器应该使用 <code>key</code> 对 <code>coll</code> 进行分组。 使用 (value, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。result 是一个 <code>Object</code>， 其属性是值的数组，其键为迭起器返回的 <code>key</code>。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.groupBy([&apos;userId1&apos;, &apos;userId2&apos;, &apos;userId3&apos;], function(userId, callback) {
    db.findById(userId, function(err, user) {
        if (err) return callback(err);
        return callback(null, user.age);
    });
}, function(err, result) {
    // result 是一个对象，它包含按照年龄分组的 usersIds。 
    // 例如 { 30: [&apos;userId1&apos;, &apos;userId3&apos;], 42: [&apos;userId2&apos;]};
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="groupBy.js.html">groupBy.js</a>, <a href="groupBy.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="groupByLimit"><span class="type-signature">(static) </span>groupByLimit<span class="signature">(coll, limit, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import groupByLimit from &apos;async/groupByLimit&apos;;</code></pre>
                        <p>与 <a href="#groupBy"><code>groupBy</code></a> 一样，但是只能同时运行最多 limit 个异步操作。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p> 同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项目的异步函数。迭代器应该使用 <code>key</code> 对值进行分组。 使用 (value, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。result 是一个 <code>Object</code>， 其属性是值的数组，其键为迭起器返回的 <code>key</code>。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="groupByLimit.js.html">groupByLimit.js</a>, <a href="groupByLimit.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#groupBy">async.groupBy</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="groupBySeries"><span class="type-signature">(static) </span>groupBySeries<span class="signature">(coll, limit, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import groupBySeries from &apos;async/groupBySeries&apos;;</code></pre>
                        <p>与 <a href="#groupBy"><code>groupBy</code></a> 一样，但同时只能运行一个异步操作。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p> 同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项目的异步函数。迭代器应该使用 <code>key</code> 对值进行分组。 使用 (value, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。result 是一个 <code>Object</code>， 其属性是值的数组，其键为迭起器返回的 <code>key</code>。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="groupBySeries.js.html">groupBySeries.js</a>, <a href="groupBySeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#groupBy">async.groupBy</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="map"><span class="type-signature">(static) </span>map<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import map from &apos;async/map&apos;;</code></pre>
                        <p>通过将 <code>coll</code> 中的每个值映射到 <code>iteratee</code> 函数，生成一个新的值集合。<code>iteratee</code> 使用来自 <code>coll</code> 的项目和一个对调函数进行调用，当它完成处理的时候，会调用这个回调。 每个回调都有两个参数:一个
                            <code>error</code>，一个来自 <code>coll</code> 被转换过的项目。 如果 <code>iteratee</code> 将一个错误传递给它的回调，那么主 <code>callback</code> (map函数的回调)会立即使用错误进行调用。</p>
                        <p>请注意，由于该函数将 <code>iteratee</code> 并行地应用于每个项目，因此无法保证 <code>iteratee</code> 函数将按顺序完成。然而，结果数组将与原来的 <code>coll</code> 的顺序相同。</p>
                        <p>如果 <code>map</code> 被传递给一个对象，结果将是一个数组。结果将大致按照原始对象的键顺序(但这可以在不同的JavaScript引擎中有所不同)。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项目的异步函数。迭代器应该完成对项目的转换。使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。 resule 是一个 <code>coll</code>经过转换后的新数组。用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.map([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], fs.stat, function(err, results) {
    // results 现在是每个文件的stats组成的数组。
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="map.js.html">map.js</a>, <a href="map.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="mapLimit"><span class="type-signature">(static) </span>mapLimit<span class="signature">(coll, limit, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import mapLimit from &apos;async/mapLimit&apos;;</code></pre>
                        <p>与 <a href="#map"><code>map</code></a> 一样，但是只能同时运行最多 limit 个异步操作。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p> 同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项目的异步函数。迭代器应该完成对项目的转换。使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。 results 是 <code>coll</code> 经过转换后的数组。 使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="mapLimit.js.html">mapLimit.js</a>, <a href="mapLimit.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#map">async.map</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="mapSeries"><span class="type-signature">(static) </span>mapSeries<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import mapSeries from &apos;async/mapSeries&apos;;</code></pre>
                        <p>与 <a href="#map"><code>map</code></a> 一样，但同时只能运行一个异步操作。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项目的异步函数。迭代器应该完成对项目的转换。使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。results 是 <code>coll</code> 经过转换后的新数组。 使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="mapSeries.js.html">mapSeries.js</a>, <a href="mapSeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#map">async.map</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="mapValues"><span class="type-signature">(static) </span>mapValues<span class="signature">(obj, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import mapValues from &apos;async/mapValues&apos;;</code></pre>
                        <p>与 <a href="#map"><code>map</code></a>相对应的，被设计用于对象。</p>
                        <p>
                            通过将 <code>obj</code> 的每个值映射到 <code>iteratee</code> 函数，生成一个新对象。
                            <code>iteratee</code> 被 <code>obj</code> 的每个键值对和一个回调调用，当它完成处理时，这个回调会被调用。 每个回调都有两个参数:一个 <code>error</code>，以及一个来自 <code>obj</code> 的经过转换的项。 如果 <code>iteratee</code> 将一个错误传递给它的回调，那么主 <code>callback</code> (对于mapValues函数)会立即被错误调用。
                        </p>
                        <p>注意，结果中的键的顺序得不到保证，这些键大致按照它们完成的顺序排列(但这是非常特定于引擎的)</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>obj</code></td>
                                <td class="type">
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>

                                <td class="description last">
                                    <p>一个被应用于 <code>coll</code> 中每一个键值对的函数。 迭代器的结果应该是一个经过转换的值。 使用 (value, key, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。
                                        <code>result</code> 是一个它包含 <code>obj</code> 中的键值对的中值经过转换后的新对象。使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.mapValues({
    f1: &apos;file1&apos;,
    f2: &apos;file2&apos;,
    f3: &apos;file3&apos;
}, function (file, key, callback) {
  fs.stat(file, callback);
}, function(err, result) {
    // result 现在是每个文件的 stats的一个映射。例如：
    // {
    //     f1: [stats for file1],
    //     f2: [stats for file2],
    //     f3: [stats for file3]
    // }
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="mapValues.js.html">mapValues.js</a>, <a href="mapValues.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="mapValuesLimit"><span class="type-signature">(static) </span>mapValuesLimit<span class="signature">(obj, limit, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import mapValuesLimit from &apos;async/mapValuesLimit&apos;;</code></pre>
                        <p>与 <a href="#mapValues"><code>mapValues</code></a> 一样，但是只能同时运行最多 limit 个异步操作。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>obj</code></td>
                                <td class="type">
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p> 同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用于 <code>coll</code> 中每一个键值对的函数。 迭代器的结果应该是一个经过转换的值。 使用 (value, key, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。
                                        <code>result</code> 是一个它包含 <code>obj</code> 中的键值对的中值经过转换后的新对象。使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="mapValuesLimit.js.html">mapValuesLimit.js</a>, <a href="mapValuesLimit.js.html#line7">line 7</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#mapValues">async.mapValues</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="mapValuesSeries"><span class="type-signature">(static) </span>mapValuesSeries<span class="signature">(obj, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import mapValuesSeries from &apos;async/mapValuesSeries&apos;;</code></pre>
                        <p>与 <a href="#mapValues"><code>mapValues</code></a> 一样，但同时只能运行一个异步操作。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>obj</code></td>
                                <td class="type">
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用于 <code>coll</code> 中每一个键值对的函数。 迭代器的结果应该是一个经过转换的值。 使用 (value, key, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个当所有 <code>iteratee</code> 函数都已经执行完毕，或者有错误发生时执行的回调函数。
                                        <code>result</code> 是一个它包含 <code>obj</code> 中的键值对的中值经过转换后的新对象。使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="mapValuesSeries.js.html">mapValuesSeries.js</a>, <a href="mapValuesSeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#mapValues">async.mapValues</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="reduce"><span class="type-signature">(static) </span>reduce<span class="signature">(coll, memo, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import reduce from &apos;async/reduce&apos;;</code></pre>
                        <p>使用一个异步 <code>iteratee</code>将 <code>coll</code> 减少为单个值，以返回每一个连续的步骤。 <code>memo</code> 是reduction的初始状态。这个函数只连续地运行。</p>
                        <p>出于性能方面的原因，将此函数的调用拆分为一个并行映射，然后在结果上使用常规的 <code>Array.prototype.reduce</code> 可能是有意义的。 这个函数适用于 reduction 需要的每一步都是异步的情况;如果在减少数据之前可以获得数据，那么这样做可能是一个好主意。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>foldl</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>memo</code></td>
                                <td class="type">
                                    <span class="param-type">*</span>
                                </td>
                                <td class="description last">
                                    <p>reduction 的初始状态。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个应用于数组中的每一个项的函数，以生成 reduction 的下一个步骤。 一个应用于数组中的每一个项的函数，以生成 reduction 的下一个步骤的状态。 如果迭代器发生错误，reduction 就会停止，并且会使用错误立即调用 <code>callback</code>。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕时调用的回调函数。result 是减少后的值。使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.reduce([1,2,3], 0, function(memo, item, callback) {
    // 毫无意义的异步:
    process.nextTick(function() {
        callback(null, memo + item)
    });
}, function(err, result) {
    // result 现在等于 memo 的最后的值，为6
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="reduce.js.html">reduce.js</a>, <a href="reduce.js.html#line6">line 6</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="reduceRight"><span class="type-signature">(static) </span>reduceRight<span class="signature">(array, memo, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import reduceRight from &apos;async/reduceRight&apos;;</code></pre>
                        <p>与 <a href="#reduce"><code>reduce</code></a> 一样，只对 <code>array</code> 进行逆序操作。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>foldr</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>array</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>memo</code></td>
                                <td class="type">
                                    <span class="param-type">*</span>
                                </td>
                                <td class="description last">
                                    <p>reduction 的初始状态。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个应用于数组中的每一个项的函数，以生成 reduction 的下一个步骤。 一个应用于数组中的每一个项的函数，以生成 reduction 的下一个步骤的状态。如果迭代器发生错误，reduction 就会停止，并且会使用错误立即调用 <code>callback</code>。 使用 (memo, item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕时调用的回调函数。result 是减少后的值。使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="reduceRight.js.html">reduceRight.js</a>, <a href="reduceRight.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#reduce">async.reduce</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="reject"><span class="type-signature">(static) </span>reject<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import reject from &apos;async/reject&apos;;</code></pre>
                        <p>与 <a href="#filter"><code>filter</code></a> 相反，移除通过 <code>async</code> 真实测试的值。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个应用于每个 <code>coll</code> 项目的异步真实测试。它的 <code>result</code> 是一个布尔值。使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕时调用的回调函数。使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.reject([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath, callback) {
    fs.access(filePath, function(err) {
        callback(null, !err)
    });
}, function(err, results) {
    // results 现在等于缺失文件的数组
    createFiles(results);
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="reject.js.html">reject.js</a>, <a href="reject.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#filter">async.filter</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="rejectLimit"><span class="type-signature">(static) </span>rejectLimit<span class="signature">(coll, limit, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import rejectLimit from &apos;async/rejectLimit&apos;;</code></pre>
                        <p>与 <a href="#reject"><code>reject</code></a> 一样，但是只能同时运行最多 limit 个异步操作。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p> 同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个应用于每个 <code>coll</code> 项目的异步真实测试。它的 <code>result</code> 是一个布尔值。 使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕时调用的回调函数。使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="rejectLimit.js.html">rejectLimit.js</a>, <a href="rejectLimit.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#reject">async.reject</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="rejectSeries"><span class="type-signature">(static) </span>rejectSeries<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import rejectSeries from &apos;async/rejectSeries&apos;;</code></pre>
                        <p>与 <a href="#reject"><code>reject</code></a> 一样，但同时只能运行一个异步操作。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个应用于每个 <code>coll</code> 项目的异步真实测试。它的 <code>result</code> 是一个布尔值。 使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕时调用的回调函数。使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="rejectSeries.js.html">rejectSeries.js</a>, <a href="rejectSeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#reject">async.reject</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="some"><span class="type-signature">(static) </span>some<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import some from &apos;async/some&apos;;</code></pre>
                        <p>如果在 <code>coll</code> 中至少有一个元素满足异步测试，那么返回 <code>true</code>。 如果任何迭代器调用返回 <code>true</code>，则会立即调用主 <code>callback</code>。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>any</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被并行应用于每个 <code>coll</code> 项目的异步真实测试。迭代器的 <code>result</code> 是一个布尔值。使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当任意一个迭代器返回 <code>true</code> 或者所有迭代器都执行完毕的时候就会被调用的回调函数。result 是 <code>true</code> 还是 <code>false</code> 取决于异步真实测试的值。使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.some([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(filePath, callback) {
    fs.access(filePath, function(err) {
        callback(null, !err)
    });
}, function(err, result) {
    // 如果 result 为 true，那么至少有一个文件是存在的
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="some.js.html">some.js</a>, <a href="some.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="someLimit"><span class="type-signature">(static) </span>someLimit<span class="signature">(coll, limit, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import someLimit from &apos;async/someLimit&apos;;</code></pre>
                        <p>与 <a href="#some"><code>some</code></a> 一样，但是只能同时运行最多 limit 个异步操作。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>anyLimit</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p> 同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个并行应用于每个 <code>coll</code> 项目的异步真实测试。 迭代器的 <code>result</code> 值是一个布尔值。 使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当任意一个迭代器返回 <code>true</code> 或者所有迭代器都执行完毕的时候就会被调用的回调函数。result 是 <code>true</code> 还是 <code>false</code> 取决于异步真实测试的值。使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="someLimit.js.html">someLimit.js</a>, <a href="someLimit.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#some">async.some</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="someSeries"><span class="type-signature">(static) </span>someSeries<span class="signature">(coll, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import someSeries from &apos;async/someSeries&apos;;</code></pre>
                        <p>与 <a href="#some"><code>some</code></a> 一样，但同时只能运行一个异步操作。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>anySeries</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个并行应用于每个 <code>coll</code> 项目的异步真实测试。迭代器 <code>result</code> 值是一个布尔值。使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当任意一个迭代器返回 <code>true</code> 或者所有迭代器都执行完毕的时候就会被调用的回调函数。result 是 <code>true</code> 还是 <code>false</code> 取决于异步真实测试的值。使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="someSeries.js.html">someSeries.js</a>, <a href="someSeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#some">async.some</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="sortBy"><span class="type-signature">(static) </span>sortBy<span class="signature">(coll, iteratee, callback)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import sortBy from &apos;async/sortBy&apos;;</code></pre>
                        <p>通过一个异步 <code>iteratee</code> 来运行每个 <code>coll</code> 值的结果来排序一个列表。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个被应用到 <code>coll</code> 中每一个项目的异步函数。迭代器应该完成一个值，作为排序条件，它的作用是它的结果。迭代器的 <code>result</code> 是一个作为排序依据的值（如javascript函数中的返回的1和-1）。使用 (item, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕或者发生错误时时调用的回调函数。results 是 <code>coll</code> 经过调用<code>iteratee</code> 函数后排序的结果。使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>

                    <pre class="prettyprint"><code>async.sortBy([&apos;file1&apos;,&apos;file2&apos;,&apos;file3&apos;], function(file, callback) {
    fs.stat(file, function(err, stats) {
        callback(err, stats.mtime);
    });
}, function(err, results) {
    // results 现在是原始的文件数组经过使用修改后的数据进行排序的结果
});

// 通过修改回调参数，可以影响排序顺序:

// 升序排序
async.sortBy([1,9,3,5], function(x, callback) {
    callback(null, x);
}, function(err,result) {
    // result callback
});

// 降序排序
async.sortBy([1,9,3,5], function(x, callback) {
    callback(null, x*-1);    //&lt;- x*-1 instead of x, turns the order around
}, function(err,result) {
    // result callback
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="sortBy.js.html">sortBy.js</a>, <a href="sortBy.js.html#line7">line 7</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="transform"><span class="type-signature">(static) </span>transform<span class="signature">(coll, accumulator<span class="signature-attributes">opt</span>, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import transform from &apos;async/transform&apos;;</code></pre>
                        <p>与 <code>reduce</code> 相关的。获取一个对象或数组，并对其每个元素进行连续的迭代，每一个步骤都可能会使一个 <code>accumulator</code> 的值发生变化。累加器的类型默认为传入的集合类型。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>coll</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个可以迭代的集合。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>accumulator</code></td>
                                <td class="type">
                                    <span class="param-type">*</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> transform 的初始装套。如果省略了, 它默认为是一个空对象或数组，这取决于 <code>coll</code> 的类型。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p> 一个被应用于集合中可能修改累加器的每个项的函数。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p> 一个当所有的 <code>iteratee</code> 函数都已执行完毕时调用的回调函数。result 是经过转换后的累加器。使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Examples</h5>
                    <pre class="prettyprint"><code>async.transform([1,2,3], function(acc, item, index, callback) {
    // 毫无意义的异步:
    process.nextTick(function() {
        acc.push(item * 2)
        callback(null)
    });
}, function(err, result) {
    // result 现在等于 [2, 4, 6]
});</code></pre>

                    <pre class="prettyprint"><code>async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {
    setImmediate(function () {
        obj[key] = val * 2;
        callback();
    })
}, function (err, result) {
    // result 等于 {a: 2, b: 4, c: 6}
})</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="transform.js.html">transform.js</a>, <a href="transform.js.html#line8">line 8</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
            </section>
            <h1 class="page-title" id="controlflow">Control Flow</h1>
            <section>
                <header>
                </header>
                <article>
                    <div class="container-overview">
                        <div class="description">
                            <p>一组 <code>async</code> 函数，用于通过脚本控制流。</p>
                        </div>
                        <dl class="details">
                            <dt class="tag-source">Source:</dt>
                            <dd class="tag-source">
                                <ul class="dummy">
                                    <li>
                                        <a href="index.js.html">index.js</a>, <a href="index.js.html#line56">line 56</a>
                                    </li>
                                </ul>
                            </dd>
                        </dl>
                    </div>
                    <h3 class="subsection-title">Methods</h3>
                    <h4 class="name" id="applyEach"><span class="type-signature">(static) </span>applyEach<span class="signature">(fns, &#x2026;args<span class="signature-attributes">opt</span>, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &#x2192; {function}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import applyEach from &apos;async/applyEach&apos;;</code></pre>
                        <p>将所提供的参数应用于数组中的每个函数，在所有函数完成后调用 <code>callback</code>。 如果您只提供第一个参数 <code>fns</code>，那么它将返回一个函数，该函数允许您传入参数，就好像它是一个单独的函数调用。 如果提供了更多的参数，则必须要提供 <code>callback</code>，而 <code>args</code> 仍然是可选的。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>fns</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一组具有相同调用参数的 <a href="global.html">AsyncFunction </a> s。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>args</code></td>
                                <td class="type">
                                    <span class="param-type">*</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>传递给函数的任意数量的独立参数。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>当所有函数都完成处理时被调用的回调，它是 <code> applyEach </code> 函数的最后一个参数。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <ul>
                            <li> 如果只提供了第一个参数 <code>fns</code>，那么它将返回一个函数，该函数允许您传入参数，就好像它是一个单独的函数调用。 这个函数的签名为 <code>(..args, callback)</code>。如果使用了任何参数调用该函数，必须指定<code>callback</code>。</li>
                        </ul>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type">function</span>
                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.applyEach([enableSearch, updateSchema], &apos;bucket&apos;, callback);

// 部分应用程序的例子:
async.each(
    buckets,
    async.applyEach([enableSearch, updateSchema]),
    callback
);</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="applyEach.js.html">applyEach.js</a>, <a href="applyEach.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="applyEachSeries"><span class="type-signature">(static) </span>applyEachSeries<span class="signature">(fns, &#x2026;args<span class="signature-attributes">opt</span>, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &#x2192; {function}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import applyEachSeries from &apos;async/applyEachSeries&apos;;</code></pre>
                        <p>与 <a href="#applyEach"><code>applyEach</code></a>一样，但同时只能运行一个异步操作。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>fns</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一组具有相同调用参数的 <a href="global.html">AsyncFunction </a> s。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>args</code></td>
                                <td class="type">
                                    <span class="param-type">*</span>
                                    <span class="optional">&lt;optional&gt;</span>

                                </td>
                                <td class="description last">
                                    <p>传递给函数的任意数量的独立参数。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>当所有函数都完成处理时被调用的回调，它是 <code> applyEach </code> 函数的最后一个参数。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <ul>
                            <li>如果只提供了第一个参数 <code>fns</code>，那么它将返回一个函数，该函数允许您传入参数，就好像它是一个单独的函数调用。</li>
                        </ul>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type">function</span>
                        </dd>
                    </dl>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="applyEachSeries.js.html">applyEachSeries.js</a>, <a href="applyEachSeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#applyEach">async.applyEach</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="auto"><span class="type-signature">(static) </span>auto<span class="signature">(tasks, concurrency<span class="signature-attributes">opt</span>, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import auto from &apos;async/auto&apos;;</code></pre>
                        <p>根据它们的需求，确定在任务中运行 <a href="global.html">AsyncFunction </a>s 的最佳顺序。 每个函数都可以选择依赖于先于它们自己完成的其他函数， 并且每个函数一旦需求得到满足都可以运行。
                        </p>
                        <p>如果任何一个 <a href="global.html">AsyncFunction </a> 将错误传递给回调， 那么
                            <code>auto</code> 序列就会停止。进一步的任务将不会执行(因此，任何依赖于它的其他函数都不会运行)， 并且主 <code>callback</code> 会立即被错误调用。</p>
                        <p><a href="global.html">AsyncFunction </a> 还接收一个包含函数（到目前为止，<code>fns</code> 中已经执行完毕的函数）结果的对象，如果它们之间有依赖关系的话。如果任务函数之前没有依赖关系，那么只会传递一个回调给它。 </p>

                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>tasks</code></td>
                                <td class="type">
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="default">
                                </td>
                                <td class="description last">
                                    <p>
                                        一个对象。它的每个属性都是一个函数或一个需求数组，而 <a href="global.html">AsyncFunction </a> 本身就是数组中的最后一个项。 对象属性的键作为该属性定义的任务的名称，也就是说，在为其他任务指定需求时可以使用它。这个函数接收到一个或两个参数:
                                    </p>
                                    <ul>
                                        <li>一个 <code>results</code> 对象，包含前面已经执行的函数的结果，仅在该任务有依赖关系的时候被传入。 </li>
                                        <li>一个 <code>callback(err, result)</code> 函数，当完成时必须调用该函数，它接收一个 <code>error</code> (可以是 <code>null</code> )和函数执行的结果。</li>
                                        </li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>concurrency</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="default">
                                    Infinity
                                </td>
                                <td class="description last">
                                    <p>一个可选的 <code>整数</code>，用来确定可以并行运行的任务的最大数量。默认情况下，尽可能多。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="default">
                                </td>
                                <td class="description last">
                                    <p>一个可选的回调，当所有的任务都完成时，它会被调用。如果任何 <code>tasks</code> 将错误传递给回调，它就会收到 <code>err</code> 参数。 results 总是被返回；但是，如果出现错误，就不会执行进一步的 <code>tasks</code>，results 对象只会包含部分结果。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>undefined</p>
                    </div>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.auto({
    // 这个函数将只会被传入一个回调
    readData: async.apply(fs.readFile, &apos;data.txt&apos;, &apos;utf-8&apos;),
    showData: [&apos;readData&apos;, function(results, cb) {
        // results.readData 是文件的内容
        // ...
    }]
}, callback);

async.auto({
    get_data: function(callback) {
        console.log(&apos;in get_data&apos;);
        // 用来获取某些数据的异步代码
        callback(null, &apos;data&apos;, &apos;converted to array&apos;);
    },
    make_folder: function(callback) {
        console.log(&apos;in make_folder&apos;);
        // 用来创建一个存储文件的文件夹的异步代码
        // 这段代码是在获取数据的同时运行的
        callback(null, &apos;folder&apos;);
    },
    write_file: [&apos;get_data&apos;, &apos;make_folder&apos;, function(results, callback) {
        console.log(&apos;in write_file&apos;, JSON.stringify(results));
        // 一旦有了一些数据，目录就存在了，
        // 将数据写入到目录中的文件
        callback(null, &apos;filename&apos;);
    }],
    email_link: [&apos;write_file&apos;, function(results, callback) {
        console.log(&apos;in email_link&apos;, JSON.stringify(results));
        // 一旦文件被写好，让我们发送一个连接给它。
        // results.write_file 包含由 write_file 返回的文件名。
        callback(null, {&apos;file&apos;:results.write_file, &apos;email&apos;:&apos;user@example.com&apos;});
    }]
}, function(err, results) {
    console.log(&apos;err = &apos;, err);
    console.log(&apos;results = &apos;, results);
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="auto.js.html">auto.js</a>, <a href="auto.js.html#line13">line 13</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="autoInject"><span class="type-signature">(static) </span>autoInject<span class="signature">(tasks, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import autoInject from &apos;async/autoInject&apos;;</code></pre>
                        <p>一个依赖注入版本的 <a href="#auto">async.auto</a> 函数。依赖任务被指定为函数的参数， 在通常的回调参数之后，参数名与所依赖的任务的名称匹配。这可以提供更易于阅读的任务图，更容易维护。
                        </p>
                        <p>如果指定了最终回调，那么任务结果也会类似地注入，在初始错误参数之后指定为命名参数。</p>
                        <p><code>autoInject</code> 函数是纯粹的语法糖，其语义与 <a href="#auto">async.auto</a> 是等价的。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>tasks</code></td>
                                <td class="type">
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>
                                        一个对象，其每个属性都是形如 <code>func([dependencies...], callback)</code>的一个<a href="global.html">AsyncFunction </a> 。 对象属性的键作为该属性定义的任务的名称，也就是说，在为其他任务指定需求时可以使用它。
                                    </p>
                                    <ul>
                                        <li><code>callback</code> 参数是一个<code>callback(err, result)</code>，当完成时必须调用它，传递一个 <code>error</code> (它可以是 <code>null</code>)和函数执行的结果。 其余的参数命名当前任务依赖的其他任务，这些任务的结果是这些 parameter 的 arguments。</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个可选的回调，当所有的任务都执行完毕的时候被调用。 如果任意的一个 <code>tasks</code> 传递了错误给他们各自的回调，它就会接收一个 <code>err</code> 参数；它还会接收一个 <code>results</code> 对象，这个对象包含任意一个已完成任务的结果，类似于<code>auto</code>。
                                    </p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>//  `auto` 的例子可以被改写如下：
async.autoInject({
    get_data: function(callback) {
        // 获取某些数据的异步代码
        callback(null, &apos;data&apos;, &apos;converted to array&apos;);
    },
    make_folder: function(callback) {
        // 创建存储文件的文件夹的异步代码
        // 与获取数据同时运行
        callback(null, &apos;folder&apos;);
    },
    write_file: function(get_data, make_folder, callback) {
        // 一旦有了一些数据，目录就存在了，
        // 将数据写入到目录中的文件
        callback(null, &apos;filename&apos;);
    },
    email_link: function(write_file, callback) {
        // 一旦文件写入完成，让我们发送一个链接给它...
        // write_file 包含 write_file 返回的文件名。
        callback(null, {&apos;file&apos;:write_file, &apos;email&apos;:&apos;user@example.com&apos;});
    }
}, function(err, results) {
    console.log(&apos;err = &apos;, err);
    console.log(&apos;email_link = &apos;, results.email_link);
});

// 如果你正在使用 JS 压缩器，它会对参数名进行管理
// `autoInject` 将不能与普通函数一起工作，因为参数名将会被折叠成一个单一的字母标识符。
// 为了解决这个问题，您可以显式地指定任务函数在数组中需要的参数名称，类似于 Angular.js 依赖注入。

// 这仍然比普通 `auto` 有优势，因为任务所依赖的结果(results)仍然会被扩展到参数中。
async.autoInject({
    //...
    write_file: [&apos;get_data&apos;, &apos;make_folder&apos;, function(get_data, make_folder, callback) {
        callback(null, &apos;filename&apos;);
    }],
    email_link: [&apos;write_file&apos;, function(write_file, callback) {
        callback(null, {&apos;file&apos;:write_file, &apos;email&apos;:&apos;user@example.com&apos;});
    }]
    //...
}, function(err, results) {
    console.log(&apos;err = &apos;, err);
    console.log(&apos;email_link = &apos;, results.email_link);
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="autoInject.js.html">autoInject.js</a>, <a href="autoInject.js.html#line24">line 24</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#auto">async.auto</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="cargo"><span class="type-signature">(static) </span>cargo<span class="signature">(worker, payload<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &#x2192; {<a href="#CargoObject">CargoObject</a>}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import cargo from &apos;async/cargo&apos;;</code></pre>
                        <p>使用指定的有效负载创建一个 <code>cargo</code> 对象。 添加到 cargo 的任务将被完全处理(达到 <code>payload</code> 限制)。 如果 <code>worker</code> 正在进行中，任务就会排队，直到它可用为止。 一旦 <code>worker</code> 完成了一些任务，就会调用这些任务的每个回调。 查看
                            <a href="https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966">这些</a>                            <a href="https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966">动画</a>动画，了解
                            <code>cargo</code> 和 <code>queue</code> 是如何工作的。
                        </p>
                        <p>当 <a href="  #queue"><code>queue</code></a> 一次只将一个任务传递给一组 worker 时，cargo 会将一组任务传递给一个 worker，并在 worker 完成时重复。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>worker</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="default">
                                </td>
                                <td class="description last">
                                    <p>用于处理队列任务数组的异步函数。使用 <code>(tasks, callback)</code> 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>payload</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="default">
                                    Infinity
                                </td>
                                <td class="description last">
                                    <p> 一个可选的 <code>整数</code>。 用于确定每轮需要处理多少任务；如果省略，默认的是无限的。
                                    </p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>一个用来管理任务的 cargo 对象。 回调可以作为特定的属性附加在 cargo 和内部队列的生命周期中监听特定的事件。
                        </p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type"><a href="#CargoObject">CargoObject</a></span>
                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>// 使用有效负载 2 创建一个 cargo 对象
var cargo = async.cargo(function(tasks, callback) {
    for (var i=0; i&lt;tasks.length; i++) {
        console.log(&apos;hello &apos; + tasks[i].name);
    }
    callback();
}, 2);

// 添加一些项目
cargo.push({name: &apos;foo&apos;}, function(err) {
    console.log(&apos;finished processing foo&apos;);
});
cargo.push({name: &apos;bar&apos;}, function(err) {
    console.log(&apos;finished processing bar&apos;);
});
cargo.push({name: &apos;baz&apos;}, function(err) {
    console.log(&apos;finished processing baz&apos;);
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="cargo.js.html">cargo.js</a>, <a href="cargo.js.html#line33">line 33</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#queue">async.queue</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="compose"><span class="type-signature">(static) </span>compose<span class="signature">(&#x2026;functions)</span><span class="type-signature"> &#x2192; {function}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import compose from &apos;async/compose&apos;;</code></pre>
                        <p>创建一个函数，它是传入的的异步函数的组成部分。 每个函数都使用后面的函数的返回值。 组合函数 <code>f()</code>, <code>g()</code>, and <code>h()</code> 产生的结果是 <code>f(g(h()))</code>，只有这个版本使用回调来获得返回值。
                        </p>
                        <p>每一个函数都是通过组合后的函数的 <code>this</code> 绑定来执行的。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>functions</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>用于组合的异步函数</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>一个异步函数，它包含被组合的一组异步函数（<code>functions</code>）。</p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type">function</span>
                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>function add1(n, callback) {
    setTimeout(function () {
        callback(null, n + 1);
    }, 10);
}

function mul3(n, callback) {
    setTimeout(function () {
        callback(null, n * 3);
    }, 10);
}

var add1mul3 = async.compose(mul3, add1);
add1mul3(4, function (err, result) {
    // result 现在等于 15
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="compose.js.html">compose.js</a>, <a href="compose.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="doDuring"><span class="type-signature">(static) </span>doDuring<span class="signature">(fn, test, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import doDuring from &apos;async/doDuring&apos;;</code></pre>
                        <p> <a href="#during"><code>during</code></a> 的后检查（post check）版本。 为了反映操作顺序的不同，参数 <code>test</code> 和 <code>fn</code> 被交换了。</p>
                        <p>同时也是<a href="#doWhilst"><code>doWhilst</code></a> 的带有异步 <code>test</code> 函数的版本。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>fn</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个每次 <code>test</code> 通过时都被调用的异步函数。 使用 (callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>test</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>用于在每次执行 <code>fn</code> 之前执行的异步的真实测试。使用 (...args, callback) 调用, 其中 <code>...args</code> 是来自于 <code>fn</code> 的前一个回调的非错误 args。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>在测试函数失败以及 <code>fn</code>的重复执行已经停止后调用的回调函数。如果发生错误，一个错误对象将会被传入 <code>callback</code> ，否则传入一个 <code>null</code>.</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="doDuring.js.html">doDuring.js</a>, <a href="doDuring.js.html#line6">line 6</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#during">async.during</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="doUntil"><span class="type-signature">(static) </span>doUntil<span class="signature">(iteratee, test, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import doUntil from &apos;async/doUntil&apos;;</code></pre>
                        <p>Like <a href="#doWhilst">&apos;doWhilst&apos;</a>, except the <code>test</code> is inverted. Note the argument ordering differs from <code>until</code>.</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个每次 <code>test</code> 通过时都被调用的异步函数。 使用 (callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>test</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p> 用来在每次 <code>iteratee</code> 执行后执行异步真实测试。使用任意 <code>iteratee</code> 的非错误回调结果调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个在测试函数已经通过并且 <code> iteratee</code> 已经停止时调用的回调。 <code>callback</code> 将被传入一个错误以及任何传递给最终的 <code>iteratee</code> 的回调的参数。使用 (err, [results]) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="doUntil.js.html">doUntil.js</a>, <a href="doUntil.js.html#line3">line 3</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#doWhilst">async.doWhilst</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="doWhilst"><span class="type-signature">(static) </span>doWhilst<span class="signature">(iteratee, test, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import doWhilst from &apos;async/doWhilst&apos;;</code></pre>
                        <p><a href="#whilst"><code>whilst</code></a> 的后检查（post-check）版本。 为了反映操作顺序的不同， <code>test</code> 和 <code>iteratee</code> 交换了位置。</p>
                        <p>
                            <code>doWhilst</code> 跟 <code>whilst</code> 的关系，普通的 JavaScript 中 <code>do while</code> 与 <code>while</code> 一般。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>每次 <code>test</code> 通过时被调用的函数。使用 (callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>test</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p> 用来在每次 <code>iteratee</code> 执行后执行异步真实测试。使用任意 <code>iteratee</code> 的非错误回调结果调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>

                                </td>
                                <td class="description last">
                                    <p>一个在测试函数已经通过并且 <code> iteratee</code> 已经停止时调用的回调。
                                        <code>callback</code> 将被传入一个错误以及任何传递给最终的 <code>iteratee</code> 的回调的参数。 使用 (err, [results]) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="doWhilst.js.html">doWhilst.js</a>, <a href="doWhilst.js.html#line7">line 7</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#whilst">async.whilst</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="during"><span class="type-signature">(static) </span>during<span class="signature">(test, fn, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import during from &apos;async/during&apos;;</code></pre>
                        <p>像 <a href="#whilst"><code>whilst</code></a> 一样， 除了 <code>test</code> 是一个异步函数，形如 <code>function (err, truth)</code> 的回调被传递给 <code>test</code>函数。 如果错误被传递给 <code>test</code> 或者 <code>fn</code> ，主回调会立即使用错误的值被调用。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>test</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p> 用于在每次执行 <code>fn</code> 之前执行的异步的真实测试，以便执行。使用 (callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>fn</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个每次 <code>test</code> 通过时都被调用的异步函数。 使用 (callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>在测试函数失败以及 <code>fn</code>的重复执行已经停止后调用的回调函数。如果发生错误，一个错误对象将会被传入 <code>callback</code> ，否则传入一个 <code>null</code>.</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>var count = 0;
async.during(
    function (callback) {
        return callback(null, count &lt; 5);
    },
    function (callback) {
        count++;
        setTimeout(callback, 1000);
    },
    function (err) {
        //  5 秒被传入
    }
);</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="during.js.html">during.js</a>, <a href="during.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#whilst">async.whilst</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="forever"><span class="type-signature">(static) </span>forever<span class="signature">(fn, errback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import forever from &apos;async/forever&apos;;</code></pre>
                        <p>使用一个回调参数调用异步函数 <code>fn</code> ，该参数允许它连续地（in series），无限地调用自己。 如果将错误传递给回调，那么错误将调用 <code>errback</code>，并且停止异步函数的执行，否则将永远不会调用它。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>fn</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个异步函数，可以反复调用。使用 (next)调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>errback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>当 <code>fn</code> 传递一个错误到它的回调，这个函数就会被调用，并且执行会停止。使用 (err) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.forever(
    function(next) {
        // next 适用于传递信息，需要一个回调（<code>callback(err [, whatever])</code>）；
        // 它将导致这个函数被再次调用。
    },
    function(err) {
        // 如果使用一个在 next 的第一个参数的值调用 next，那么它会出现在这里作为  &apos;err&apos；并且执行会停止。
    }
);</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="forever.js.html">forever.js</a>, <a href="forever.js.html#line7">line 7</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="parallel"><span class="type-signature">(static) </span>parallel<span class="signature">(tasks, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import parallel from &apos;async/parallel&apos;;</code></pre>
                        <p>
                            并行地运行函数的 <code>tasks</code> 集合，而不等待上一个函数完成。 如果任意函数将错误传递给它们的回调，那么主 <code>callback</code> 就会立即被该错误的值调用。 一旦 <code>tasks</code> 完成，结果将作为数组传递给最终 <code>callback</code> 。

                            <p><strong>注意:</strong> <code>parallel</code> 是在并行地完成 I/O 任务，而不是并行地执行代码。 如果您的任务不使用任何计时器或执行任何 I/O，它们实际上将串行地（in series）执行。 每个任务的同步设置部分将会相继出现。 JavaScript 仍然是单线程的。
                            </p>
                            <p><strong>提示:</strong> 当一个任务失败时，使用 <a href="#reflect"><code>reflect</code></a> 来继续其他任务的执行。</p>
                            <p>也可以使用对象而不是数组。每个属性将作为函数运行，运行的结果将作为对象（而不是数组）被传递给最终的<code>callback</code>。 这可以是一种更可读的方法来处理 async.parallel 的结果。
                            </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>tasks</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个用于执行的<a href="global.html">异步函数</a>集合。 每个异步函数可以有任意数量的可选 <code>result</code> 值。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>
                                        一个可选的回调，一旦所有的函数都成功完成，就可以运行了。 这个函数有一个 results 数组(或者 对象)，它包含了传递给任务回调的所有 result 参数。 使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.parallel([
    function(callback) {
        setTimeout(function() {
            callback(null, &apos;one&apos;);
        }, 200);
    },
    function(callback) {
        setTimeout(function() {
            callback(null, &apos;two&apos;);
        }, 100);
    }
],
// 可选回调
function(err, results) {
    // results 数组将等于 [&apos;one&apos;,&apos;two&apos;]
    // 尽管第二个函数有一个更短些的超时。
});

// 一个使用对象（而不是数组）的示例
async.parallel({
    one: function(callback) {
        setTimeout(function() {
            callback(null, 1);
        }, 200);
    },
    two: function(callback) {
        setTimeout(function() {
            callback(null, 2);
        }, 100);
    }
}, function(err, results) {
    // results 现在等于: {one: 1, two: 2}
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="parallel.js.html">parallel.js</a>, <a href="parallel.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="parallelLimit"><span class="type-signature">(static) </span>parallelLimit<span class="signature">(tasks, limit, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import parallelLimit from &apos;async/parallelLimit&apos;;</code></pre>
                        <p>与 <a href="#parallel"><code>parallel</code></a> 一样，但是只能同时运行最多 limit 个异步操作。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>tasks</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个用于执行的 <a href="global.html">异步函数</a> 集合。 每个异步函数可以有任意数量的可选 <code>result</code> 值。
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p> 同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个可选的回调，一旦所有的函数都成功完成，就可以运行了。 这个函数有一个 results 数组(或者 对象)，它包含了传递给任务回调的所有 result 参数。 使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="parallelLimit.js.html">parallelLimit.js</a>, <a href="parallelLimit.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#parallel">async.parallel</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="priorityQueue"><span class="type-signature">(static) </span>priorityQueue<span class="signature">(worker, concurrency)</span><span class="type-signature"> &#x2192; {<a href="#QueueObject">QueueObject</a>}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import priorityQueue from &apos;async/priorityQueue&apos;;</code></pre>
                        <p>与 <a href="#queue">async.queue</a> 一样，只有任务被指定优先级，并按照提升优先级顺序完成。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>worker</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个处理队列任务的异步函数。 如果你想处理来自个别任务的错误，传递一个回调到 <code>q.push()</code>。 使用 (task, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>concurrency</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p>一个<code>整数</code>， 用来确定并行运行的 <code>worker</code> 函数的数量的。如果省略，默认为 <code>1</code>。如果为 <code>0</code>，将会抛出一个错误。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>一个用于管理任务的队列对象。<code>queue</code> 和 <code>priorityQueue</code> 对象有两个不同点</p>
                        <ul>
                            <li><code>push(task, priority, [callback])</code> - <code>priority</code> 是一个数组。如果给定的是一个 <code>tasks</code> 数组，所有的任务将被指定相同的优先级。</li>
                            <li><code>unshift</code> 方法被移除了。</li>
                        </ul>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type"><a href="#QueueObject">QueueObject</a></span>
                        </dd>
                    </dl>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="priorityQueue.js.html">priorityQueue.js</a>, <a href="priorityQueue.js.html#line8">line 8</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#queue">async.queue</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="queue"><span class="type-signature">(static) </span>queue<span class="signature">(worker, concurrency<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &#x2192; {<a href="#QueueObject">QueueObject</a>}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import queue from &apos;async/queue&apos;;</code></pre>
                        <p>使用指定的 <code>concurrency</code> 创建一个 <code>queue</code> 对象。 任务被添加到 <code>queue</code>，并被并行地处理(知道达到 <code>concurrency</code> 的限制)。 如果所有的 <code>worker</code> 都正在进行，任务会排队等待，直到有一个可用。 一旦 <code>worker</code> 完成了一个 <code>task</code>，这个
                            <code>task</code> 的回调就会被调用。
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>worker</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="default">
                                </td>
                                <td class="description last">
                                    <p>一个处理队列任务的异步函数。 如果你想处理来自个别任务的错误，传递一个回调到 <code>q.push()</code>。 使用 (task, callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>concurrency</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="default">
                                    1
                                </td>
                                <td class="description last">
                                    <p>一个<code>整数</code>，用来确定并行运行的 <code>worker</code> 函数的数量。如果省略，默认为 <code>1</code>。如果为 <code>0</code>，将会抛出一个错误。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p> 一个用于管理任务的队列对象。 回调可以作为特定的属性附加在队列的生命周期中监听特定的事件。</p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type"><a href="#QueueObject">QueueObject</a></span>
                        </dd>
                    </dl>
                    <h5>Example</h5>

                    <pre class="prettyprint"><code>// 使用 concurrency 2 创建一个队列对象。
var q = async.queue(function(task, callback) {
    console.log(&apos;hello &apos; + task.name);
    callback();
}, 2);

// 指定一个回调
q.drain = function() {
    console.log(&apos;all items have been processed&apos;);
};

// 添加一些项目到队列
q.push({name: &apos;foo&apos;}, function(err) {
    console.log(&apos;finished processing foo&apos;);
});
q.push({name: &apos;bar&apos;}, function (err) {
    console.log(&apos;finished processing bar&apos;);
});

// 添加一些项目到队列 (batch-wise 分批的)
q.push([{name: &apos;baz&apos;},{name: &apos;bay&apos;},{name: &apos;bax&apos;}], function(err) {
    console.log(&apos;finished processing item&apos;);
});

//  添加一些项目到队首
q.unshift({name: &apos;bar&apos;}, function (err) {
    console.log(&apos;finished processing bar&apos;);
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="queue.js.html">queue.js</a>, <a href="queue.js.html#line58">line 58</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="race"><span class="type-signature">(static) </span>race<span class="signature">(tasks, callback)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import race from &apos;async/race&apos;;</code></pre>
                        <p>并行地运行 <code>tasks</code> 函数数组，不需要等待以前的函数完成。 一旦 <code>tasks</code> 中的任意一个任务完成或者传递了一个错误给它的回调，主 <code>callback</code> 就会被立即调用。 等效于 <code>Promise.race()</code>。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>tasks</code></td>

                                <td class="type">
                                    <span class="param-type">Array</span>
                                </td>
                                <td class="description last">
                                    <p>一个用于执行的 <a href="global.html">异步函数</a> 数组。 每个函数都可以有一个可选的 <code>result</code> 值。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个回调，一旦任意一个任务函数完成就会运行。 这个函数会获得一个错误或者第一个执行完毕的函数的结果。 使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>undefined</p>
                    </div>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.race([
    function(callback) {
        setTimeout(function() {
            callback(null, &apos;one&apos;);
        }, 200);
    },
    function(callback) {
        setTimeout(function() {
            callback(null, &apos;two&apos;);
        }, 100);
    }
],
// 主回调
function(err, result) {
    // 借过等于 &apos;two&apos;，因为它完成得更早。
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="race.js.html">race.js</a>, <a href="race.js.html#line6">line 6</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="retry"><span class="type-signature">(static) </span>retry<span class="signature">(opts<span class="signature-attributes">opt</span>, task, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import retry from &apos;async/retry&apos;;</code></pre>
                        <p>
                            在返回错误之前，尝试从 <code>task</code> 中获得成功的响应的次数不超过 <code>times</code>。 如果任务成功，则 <code>callback</code> 将被传入成功任务的结果。 如果所有尝试都失败了，那么回调将被传入最终尝试的错误和结果(如果有的话)。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>opts</code></td>
                                <td class="type">
                                    <span class="param-type">Object</span> |
                                    <span class="param-type">number</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="default">
                                    {times: 5, interval: 0}| 5
                                </td>
                                <td class="description last">
                                    <p>Can be either an object with <code>times</code> and <code>interval</code> or a number.</p>
                                    <ul>
                                        <li><code>times</code> - 放弃之前尝试的次数。默认值为 <code>5</code>.</li>
                                        <li><code>interval</code> - 重试之间等待的时间, 以毫秒为单位。默认值为 <code>0</code>。interval 也可以指定为重试计数的函数(请参见示例)。</li>
                                        <li><code>errorFilter</code> - 在错误结果中调用的可选同步函数。如果函数返回 <code>true</code>，重试将继续；如果函数返回 <code>false</code>， 在当前尝试的错误和结果被返回到最终回调的情况下，重试流会被中止。 使用 (err) 调用。</li>
                                        <li>如果 <code>opts</code> 是一个数字，这个数字指定了重试的次数，使用默认的间隔 <code>0</code>.</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>task</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="default">
                                </td>
                                <td class="description last">
                                    <p>用于重试的异步函数。使用 (callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="default">
                                </td>
                                <td class="description last">
                                    <p>一个可选的回调，当任务成功执行，或者最终的尝试失败的时候被调用。它接受完成 <code>task</code> 时的最后一次尝试的 <code>err</code> 和 <code>result</code> 参数。 使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>// The `retry` function can be used as a stand-alone control flow by passing
// 一个回调，如下所示:

// 尝试调用 apiMethod 3 次
async.retry(3, apiMethod, function(err, result) {
    // 使用result 做点什么事儿
});

//尝试调用 apiMethod 3 次, 每次尝试间等待 200 ms
async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
    // 使用result 做点什么事儿
});

// 使用指数后移调用 apiMethod 10次
// (即 intervals of 100, 200, 400, 800, 1600, ... 毫秒)
async.retry({
  times: 10,
  interval: function(retryCount) {
    return 50 * Math.pow(2, retryCount);
  }
}, apiMethod, function(err, result) {
    // 使用result 做点什么事儿
});

// 使用默认的 0 间隔，5次 尝试调用 apiMethod。
async.retry(apiMethod, function(err, result) {
    // 使用result 做点什么事儿
});

// 仅当错误条件满足时尝试调用 apiMethod，所有其他错误将中止重试控制流并返回到最终回调
async.retry({
  errorFilter: function(err) {
    return err.message === &apos;Temporary error&apos;; // 仅当发生指定错误时继续重试。
  }
}, apiMethod, function(err, result) {
    // 使用result 做点什么事儿
});

// 要在其他控制流函数中重试不可靠的个别方法，请使用 `retryable` 包装器:
async.auto({
    users: api.getUsers.bind(api),
    payments: async.retryable(3, api.getPayments.bind(api))
}, function(err, results) {
    // 使用result 做点什么事儿
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="retry.js.html">retry.js</a>, <a href="retry.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#retryable">async.retryable</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="retryable"><span class="type-signature">(static) </span>retryable<span class="signature">(opts<span class="signature-attributes">opt</span>, task)</span><span class="type-signature"> &#x2192; {<a href="global.html">AsyncFunction </a>}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import retryable from &apos;async/retryable&apos;;</code></pre>
                        <p>与 <a href="#retry"><code>retry</code></a> 密切相关的。 这个方法将一个任务包装起来，并使它可以重试，而不是立即用重试的方式来调用它。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Default</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>opts</code></td>
                                <td class="type">
                                    <span class="param-type">Object</span> |
                                    <span class="param-type">number</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="default">
                                    {times: 5, interval: 0}| 5
                                </td>
                                <td class="description last">
                                    <p>可选选项, 与 <code>retry</code> 完全一样。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>task</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="default">
                                </td>
                                <td class="description last">
                                    <p>用于包装的异步函数。这个函数将被传入返回的包装器。包装器函数可以接受任意的参数。 使用 (...args, callback) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>包装后的函数，在错误时会基于指定的 <code>opts</code> 参数被调用进行重试。 这个函数将接受与 <code>task</code> 相同的参数。</p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.auto({
    dep1: async.retryable(3, getFromFlakyService),
    process: [&quot;dep1&quot;, async.retryable(3, function (results, cb) {
        maybeProcessData(results.dep1, cb);
    })]
}, callback);</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="retryable.js.html">retryable.js</a>, <a href="retryable.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#retry">async.retry</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="seq"><span class="type-signature">(static) </span>seq<span class="signature">(&#x2026;functions)</span><span class="type-signature"> &#x2192; {function}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import seq from &apos;async/seq&apos;;</code></pre>
                        <p><a href="#compose"><code>compose</code>函数</a>的阅读更自然的版本。 每个函数都使用前一个函数的返回值。 它等价于使用反转参数的 <a href="#compose">compose</a>。「译者注：阅读体验更自然是因为，我们的阅读习惯现在是从左到右的，从上到下的，从前到后的。然而compose则相反。」</p>
                        <p>每个函数都使用组合后的 <code>this</code> 绑定来执行。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>functions</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>用来组合的一组异步函数。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>一个函数，它是按照顺序组合的 <code>functions</code>。</p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type">function</span>
                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>// 加载 lodash (或者 underscore), express3 和 dresende 的 orm2.
// 应用程序的一部分，这将获取已登录用户的cats。
// 这个示例使用 `seq` 函数来避免过度嵌套和错误。
// 处理混乱。
app.get(&apos;/cats&apos;, function(request, response) {
    var User = request.models.User;
    async.seq(
        _.bind(User.get, User),  // &apos;User.get&apos; 有签名 (id, callback(err, data))
        function(user, fn) {
            user.getCats(fn);      // &apos;getCats&apos; 有签名 (callback(err, data))
        }
    )(req.session.user_id, function (err, cats) {
        if (err) {
            console.error(err);
            response.json({ status: &apos;error&apos;, message: err.message });
        } else {
            response.json({ status: &apos;ok&apos;, message: &apos;Cats found&apos;, data: cats });
        }
    });
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="seq.js.html">seq.js</a>, <a href="seq.js.html#line7">line 7</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#compose">async.compose</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="series"><span class="type-signature">(static) </span>series<span class="signature">(tasks, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import series from &apos;async/series&apos;;</code></pre>
                        <p>
                            在 <code>tasks</code> 集合中连续地运行这个函数，每个运行一次，之前的函数都已经完成了。 如果 series 中的任何函数传递了一个错误给它的回调，那么不会有更多的函数被运行，并且 <code>callback</code> 会使用这个错误的值立即被调用。 否则，当 <code>tasks</code> 完成时， <code>callback</code> 会接收一个结果数组。
                            <p>
                                它也可以使用对象而不是数组。 任何一个属性将作为函数运行，运行的结果将会作为一个对象（而不是数组）被传递到最终的 <code>callback</code> 。 这可以是一种用来处理 async.series 的更可读的方式。</p>
                            <p><strong>注意：</strong> 尽管许多实现保留了对象属性的顺序，<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-8.6">ECMAScript 语言规范n</a> 明确声明：</p>
                            <blockquote>
                                <p>列举的这些属性的结构和顺序没有被指定。</p>
                            </blockquote>
                            <p>因此，如果您依赖于执行一连串函数的顺序，并希望它在所有平台上工作，那么可以考虑使用数组。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>tasks</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>一个用来串行运行的<a href="global.html">异步函数</a>集合。 每个函数都可以有任意数量的可选 <code>result</code> 值。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个可选的回调，一旦所有的函数都完成了就运行。 这个函数会得到一个 results 数组（或者对象），它包含了被传递到 所有 <code>task</code> 回调的 result 参数。使用 (err, result) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.series([
    function(callback) {
        // 做一些事情 ...
        callback(null, &apos;one&apos;);
    },
    function(callback) {
        // 做更多事情...
        callback(null, &apos;two&apos;);
    }
],
// 可选的回调
function(err, results) {
    // results 现在等于 [&apos;one&apos;, &apos;two&apos;]
});

async.series({
    one: function(callback) {
        setTimeout(function() {
            callback(null, 1);
        }, 200);
    },
    two: function(callback){
        setTimeout(function() {
            callback(null, 2);
        }, 100);
    }
}, function(err, results) {
    // results 现在等于: {one: 1, two: 2}
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="series.js.html">series.js</a>, <a href="series.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="times"><span class="type-signature">(static) </span>times<span class="signature">(n, iteratee, callback)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import times from &apos;async/times&apos;;</code></pre>
                        <p>调用 <code>iteratee</code> 函数 <code>n</code> 次, 并以与 <a href="#map">map</a> 相同的方式积累结果。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>n</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p>运行该函数的次数。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>那个应该被调用 <code>n</code> 次的异步函数。使用迭代索引和一个回调调用：(n, next).</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>参见 <a href="#map">map</a>.</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>// Pretend this is some complicated async factory
var createUser = function(id, callback) {
    callback(null, {
        id: &apos;user&apos; + id
    });
};

// 生成 5 个用户
async.times(5, function(n, next) {
    createUser(n, function(err, user) {
        next(err, user);
    });
}, function(err, users) {
    // 我们现在应该有 5 个user
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="times.js.html">times.js</a>, <a href="times.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#map">async.map</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="timesLimit"><span class="type-signature">(static) </span>timesLimit<span class="signature">(count, limit, iteratee, callback)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import timesLimit from &apos;async/timesLimit&apos;;</code></pre>
                        <p>与 <a href="#times">times</a>一样，但是只能同时运行最多 limit 个异步操作。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>count</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p>运行该函数的次数。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>limit</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p> 同时可以运行的异步操作的最大数量。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>那个应该被调用 <code>n</code> 次的异步函数。使用迭代索引和一个回调调用：(n, next).</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>参见 <a href="#map">async.map</a>.</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="timesLimit.js.html">timesLimit.js</a>, <a href="timesLimit.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#times">async.times</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="timesSeries"><span class="type-signature">(static) </span>timesSeries<span class="signature">(n, iteratee, callback)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import timesSeries from &apos;async/timesSeries&apos;;</code></pre>
                        <p>与 <a href="#times">times</a> 一样，但同时只能运行一个异步操作。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>n</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p>运行该函数的次数。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>那个应该被调用 <code>n</code> 次的异步函数。使用迭代索引和一个回调调用：(n, next).</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>see <a href="#map">map</a>.</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="timesSeries.js.html">timesSeries.js</a>, <a href="timesSeries.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#times">async.times</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="tryEach"><span class="type-signature">(static) </span>tryEach<span class="signature">(tasks, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import tryEach from &apos;async/tryEach&apos;;</code></pre>
                        <p>
                            它以串行的方式运行每一个任务，但是当任何函数成功时就会停止。 如果其中一个任务成功，则 <code>callback</code> 将被传入成功任务的结果。 如果所有的任务都失败了，那么回调将会被传入最终尝试的错误和结果(如果有的话)。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>tasks</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Iterable</span> |
                                    <span class="param-type">Object</span>
                                </td>
                                <td class="description last">
                                    <p>
                                        一个包含运行的所有函数的集合， 每个函数都被传入一个 <code>callback(err, result)</code>， 这个回调必须使用一个错误 error <code>err</code> 和一个可选的 <code>result</code> 值进行调用。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>
                                        一个可选的回调，当所有任务的中的其中一个成功完成或者所有的任务都失败时被调用。 它接受 <code>task</code> 完成时的最后一次尝试的<code>err</code> 和 <code>result</code> 参数 。使用 (err, results) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.tryEach([
    function getDataFromFirstWebsite(callback) {
        // 尝试从第一个网站获取数据
        callback(err, data);
    },
    function getDataFromSecondWebsite(callback) {
        // 从第一个网站获取数据失败,
        // 尝试从备用网站获取数据
        callback(err, data);
    }
],
// 可选的回调
function(err, results) {
    // 现在使用获取的数据做点事情
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="tryEach.js.html">tryEach.js</a>, <a href="tryEach.js.html#line6">line 6</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="until"><span class="type-signature">(static) </span>until<span class="signature">(test, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import until from &apos;async/until&apos;;</code></pre>
                        <p>重复地调用 <code>iteratee</code> 直到 <code>test</code> 返回 <code>true</code>。如果任何迭代器调用返回。 当停止或者发生错误时调用 <code>callback</code> 。
                            <code>callback</code> 将被传入一个错误以及任何传递给最终的 <code>iteratee</code> 的回调的参数。</p>
                        <p>与 <a href="#whilst">whilst</a>相反。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>test</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>用于在每次执行 <code>iteratee</code> 之前执行的异步真实测试。使用 () 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>每次 <code>test</code> 失败时调用的异步函数。使用 (callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个在测试函数已经通过并且 <code> iteratee</code> 已经停止时调用的回调。
                                        <code>callback</code> 将被传入一个错误以及任何传递给最终的 <code>iteratee</code> 的回调的参数。 使用 (err, [results]) 调用。
                                    </p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="until.js.html">until.js</a>, <a href="until.js.html#line3">line 3</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#whilst">async.whilst</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="waterfall"><span class="type-signature">(static) </span>waterfall<span class="signature">(tasks, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import waterfall from &apos;async/waterfall&apos;;</code></pre>
                        <p>
                            连续地运行 <code>tasks</code> 函数数组， 每一个都将结果传递给数组中的下一个。 但是，如果任意一个 <code>tasks</code> 将错误传递给自己的回调，则不会执行下一个函数，并且会立即调用主<code>callback</code>。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>tasks</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span>
                                </td>
                                <td class="description last">
                                    <p> 一个用来执行的 <a href="global.html">异步函数</a> 数组。 每个函数都可以有任意数量的 <code>result</code> 值。
                                        <code>result</code> 将会被作为参数按顺序传递给下一个任务。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>

                                </td>
                                <td class="description last">
                                    <p>一个可选的回调，一旦所有的函数都完成了就运行。 最后一个任务的回调的 results 将给它。使用 (err, [results]) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>undefined</p>
                    </div>
                    <h5>Example</h5>

                    <pre class="prettyprint"><code>async.waterfall([
    function(callback) {
        callback(null, &apos;one&apos;, &apos;two&apos;);
    },
    function(arg1, arg2, callback) {
        // arg1 现在等于 &apos;one&apos; ， arg2 现在等于 &apos;two&apos;
        callback(null, &apos;three&apos;);
    },
    function(arg1, callback) {
        // arg1 现在等于 &apos;three&apos;
        callback(null, &apos;done&apos;);
    }
], function (err, result) {
    // result 现在等于 &apos;done&apos;
});

// 或者, 使用命名函数:
async.waterfall([
    myFirstFunction,
    mySecondFunction,
    myLastFunction,
], function (err, result) {
    // result 现在等于 &apos;done&apos;
});
function myFirstFunction(callback) {
    callback(null, &apos;one&apos;, &apos;two&apos;);
}
function mySecondFunction(arg1, arg2, callback) {
    // arg1 现在等于 &apos;one&apos; ， arg2 现在等于 &apos;two&apos;
    callback(null, &apos;three&apos;);
}
function myLastFunction(arg1, callback) {
    // arg1 现在等于 &apos;three&apos;
    callback(null, &apos;done&apos;);
}</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="waterfall.js.html">waterfall.js</a>, <a href="waterfall.js.html#line9">line 9</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="whilst"><span class="type-signature">(static) </span>whilst<span class="signature">(test, iteratee, callback<span class="signature-attributes">opt</span>)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import whilst from &apos;async/whilst&apos;;</code></pre>
                        <p>如果 <code>test</code> 返回 <code>true</code>，那么就反复调用 <code>iteratee</code>。 当停止时或者发生错误时调用 <code>callback</code> 。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>test</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>用于在每次执行 <code>iteratee</code> 之前执行的异步真实测试。使用 () 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>iteratee</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>每次 <code>test</code> 通过时调用的异步函数。 使用 (callback) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                    <span class="optional">&lt;optional&gt;</span>
                                </td>
                                <td class="description last">
                                    <p>一个在测试函数失败以及被反复执行的 <code>iteratee</code> 已经停止时调用的回调。
                                        <code>callback</code> 将被传入一个错误以及任何传递给最终的 <code>iteratee</code> 的回调的参数。 &apos;s callback. 使用 (err, [results]) 调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>undefined</p>
                    </div>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>var count = 0;
async.whilst(
    function() { return count &lt; 5; },
    function(callback) {
        count++;
        setTimeout(function() {
            callback(null, count);
        }, 1000);
    },
    function (err, n) {
        // 5 seconds 被传入, n = 5
    }
);</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="whilst.js.html">whilst.js</a>, <a href="whilst.js.html#line7">line 7</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h3 class="subsection-title">Type Definitions</h3>
                    <h4 class="name" id="CargoObject">CargoObject</h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import cargo from &apos;async/cargo&apos;;</code></pre>
                        <p> 任务中的一个 cargo，用于被 worker 函数完成。 cargo 继承了所有与 <a href="#queue"><code>queue</code></a> 相同的方法和事件回调>。</p>
                    </div>
                    <h5>Type:</h5>
                    <ul>
                        <li>
                            <span class="param-type">Object</span>
                        </li>
                    </ul>
                    <h5 class="subsection-title">Properties:</h5>
                    <table class="props">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>length</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>
                                        一个函数，用来返回等待处理的条目的数量的。 像 <code>cargo.length()</code> 一样调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>payload</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p>一个 <code>整数</code>， 用来确定每一轮有多少个任务被处理。 这个属性可以在创建了一个可以在运行中动态改变负载（payload）的 <code>cargo</code> 后被改变。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>push</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>添加 <code>task</code> 到 <code>queue</code> 中。 一旦 <code>worker</code> 完成了任务，就会调用回调。 可以提交一个 <code>tasks</code>数组，而不是单个任务。 相应的回调用于列表中的每个任务。像
                                        <code>cargo.push(task, [callback])</code> 这样调用。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>saturated</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p> 当 <code>queue.length()</code> 到达并发限制时（concurrency），将会调用一个回调，并且进一步的任务将被排队。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>empty</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个回调，当 <code>queue</code> 的最后最后一个项目被交给 <code>worker</code> 时调用。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>drain</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>当 <code>queue</code> 中的最后一个项目从 <code>worker</code> 被返回时，将调用一个回调。「译者注：也就是队列执行完毕。」</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>idle</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个函数，如果存在等待或处理的项，则返回false；如果不是，则返回 true。 像 <code>cargo.idle()</code> 这样调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>pause</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个函数，它可以暂停处理任务，直到 <code>resume()</code> 被调用。像 <code>cargo.pause()</code>这样调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>resume</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>
                                        一个函数，它可以恢复处理被暂停的任务队列，像 <code>cargo.resume()</code> 这样调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>kill</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个函数，它可以移除 <code>drain</code> 回调，清空队列中剩余的任务，迫使其进入空闲（idle 状态）。 像 <code>cargo.kill()</code> 这样调用。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="cargo.js.html">cargo.js</a>, <a href="cargo.js.html#line3">line 3</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="QueueObject">QueueObject</h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import queue from &apos;async/queue&apos;;</code></pre>
                        <p>一个用于被 worker 函数完成的任务队列。</p>
                    </div>
                    <h5>Type:</h5>
                    <ul>
                        <li>
                            <span class="param-type">Object</span>
                        </li>
                    </ul>
                    <h5 class="subsection-title">Properties:</h5>
                    <table class="props">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>length</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个函数，用于返回等待被处理的项目的数量。像 <code>queue.length()</code> 这样调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>started</code></td>
                                <td class="type">
                                    <span class="param-type">boolean</span>
                                </td>
                                <td class="description last">
                                    <p>一个布尔值，用以指示是否有任何项目被队列所推入和处理。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>running</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个函数，用以返回正在被处理的项目的数量。像 <code>queue.running()</code> 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>workersList</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个函数，返回当前正在被处理的项目的数组。像 <code>queue.workersList()</code> 这样调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>idle</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个函数，用以指示当前队列是否处理空闲状态。有项目在等待或者正在被处理，则返回false，如果为空，则返回 true。 这样调用： <code>queue.idle()</code>。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>concurrency</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p>一个整数，用于确定 并行运行的 <code>worker</code> 的数量。 这个属性可以在创建了一个可以在运行中动态改变并发性（concurrency）的 <code>queue</code> 后被改变。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>push</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>

                                <td class="description last">
                                    <p>添加一个新任务到 <code>queue</code>。一旦 <code>worker</code> 已经完成正在处理的任务，就会调用 <code>callback</code>。 可以提交一个 <code>tasks</code> 数组，而不是单个任务。 相应的回调用于列表中的每个任务。 像这样调用： <code>queue.push(task, [callback])</code>。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>unshift</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>添加一个新的任务到 <code>queue</code> 头部。 这样调用： <code>queue.unshift(task, [callback])</code>。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>remove</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>
                                        从队列中移除与 test 函数匹配的项目。 test 函数将获得一个对象，如果这是一个 <a href="#priorityQueue">priorityQueue</a> 对象，那么该对象有一个<code>data</code>属性、一个 <code>priority</code> 属性， 像这样使用 <code>queue.remove(testFn)</code>， 其中 <code>testFn</code>                                        是一个形如 <code>function ({data, priority}) {}</code> 这样的函数，它返回一个布尔值。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>saturated</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个回调，当运行的 worker 数量超过 <code>concurrency</code> 的限制时被调用， 进一步的任务将被排队。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>unsaturated</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个回调，当运行的 worker 数量小于 <code>concurrency</code> &amp; <code>buffer</code> 的限制时被调用。 进一步的任务不会被排队。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>buffer</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p>一个最小阈值缓冲区,用于表示 <code>queue</code> 是 <code>unsaturated</code>。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>empty</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个回调，当 <code>queue</code> 的最后最后一个项目被交给 <code>worker</code> 时调用。
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>drain</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>当 <code>queue</code> 中的最后一个项目从 <code>worker</code> 被返回时，将调用一个回调。「译者注：也就是队列执行完毕。」</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>error</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个回调，当任务出现错误时被调用。有签名如： <code>function(error, task)</code>。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>paused</code></td>
                                <td class="type">
                                    <span class="param-type">boolean</span>
                                </td>
                                <td class="description last">
                                    <p>一个布尔值，用于确定队列是否处于暂停状态。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>pause</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个函数，它可以暂停处理任务，直到 <code>resume()</code> 被调用。像 <code>queue.pause()</code>这样调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>resume</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个函数，它可以恢复被暂停处理的队列。 像这样调用 <code>queue.resume()</code>。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>kill</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个函数，用以移除 <code>drain</code> 回调和清空队列中的任务，将其强制置为空闲。 在调用这个函数之后，不应该再将任务推入队列中。这样使用： <code>queue.kill()</code>。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="queue.js.html">queue.js</a>, <a href="queue.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
            </section>
            <h1 class="page-title" id="utils">Utils</h1>
            <section>
                <header>
                </header>
                <article>
                    <div class="container-overview">
                        <div class="description">
                            <p>一个<code>异步</code> 工具函数集。</p>
                        </div>
                        <dl class="details">
                            <dt class="tag-source">Source:</dt>
                            <dd class="tag-source">
                                <ul class="dummy">
                                    <li>
                                        <a href="index.js.html">index.js</a>, <a href="index.js.html#line61">line 61</a>
                                    </li>
                                </ul>
                            </dd>
                        </dl>
                    </div>
                    <h3 class="subsection-title">Methods</h3>
                    <h4 class="name" id="apply"><span class="type-signature">(static) </span>apply<span class="signature">(fn)</span><span class="type-signature"> &#x2192; {function}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import apply from &apos;async/apply&apos;;</code></pre>
                        <p>使用一些已经应用的参数创建一个接续函数（continuation function）。</p>

                        <p>当与其他控制流函数结合时，作为简写很有帮助。 传递给返回的函数的任何参数都被添加到最初的函数（传递给 apply的）的参数中。「译者注：也就上面的<code>fn</code>。」
                        </p>
                        <p>「译者注：这里的接续函数是指，使用apply 包裹 fn 后创建的函数可以接收任意数量的参数，并且该函数会挨个对这些参数进行处理。」</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>fn</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>你想要最终应用所有参数的函数。使用 (arguments...) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>arguments...</code></td>
                                <td class="type">
                                    <span class="param-type">*</span>
                                </td>
                                <td class="description last">
                                    <p>当接续函数被调用时，会自动应用任何数量的参数。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>局部应用（partially-applied）的函数</p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type">function</span>
                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>// 使用 apply
async.parallel([
    async.apply(fs.writeFile, &apos;testfile1&apos;, &apos;test1&apos;),
    async.apply(fs.writeFile, &apos;testfile2&apos;, &apos;test2&apos;)
]);


// 与不使用 apply 的相同过程
async.parallel([
    function(callback) {
        fs.writeFile(&apos;testfile1&apos;, &apos;test1&apos;, callback);
    },
    function(callback) {
        fs.writeFile(&apos;testfile2&apos;, &apos;test2&apos;, callback);
    }
]);

// 当调用 continuation 时，它可以被传入任意数量的附加参数：

node&gt; var fn = async.apply(sys.puts, &apos;one&apos;);
node&gt; fn(&apos;two&apos;, &apos;three&apos;);
one
two
three</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="apply.js.html">apply.js</a>, <a href="apply.js.html#line3">line 3</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="asyncify"><span class="type-signature">(static) </span>asyncify<span class="signature">(func)</span><span class="type-signature"> &#x2192; {<a href="global.html">AsyncFunction </a>}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import asyncify from &apos;async/asyncify&apos;;</code></pre>
                        <p>
                            使用一个同步函数并使其为异步化，将其返回值传递给一个回调函数。 这对于将同步函数插入瀑布（waterfall）、序列（series）或其他异步函数非常有用。 传递给生成的函数的任何参数都将被传递给包裹函数(除了参数中处于最后的回调
                            <code>f(args..., callback)</code>)。 抛出的错误将被传递给回调。
                        </p>
                        <p>
                            如果传递给 <code>asyncify</code> 的函数返回一个 Promise，那么这个承诺的 resolved/rejected 状态将被用于调用回调，而不是简单的同步返回值。
                        </p>
                        <p>
                            这也意味着您可以将 ES2017 <code>async</code> 函数异步化。</p>
                    </div>
                    <dl class="details alias-details">
                        <dt class="tag-alias">Alias:</dt>
                        <dd class="tag-alias">
                            <ul class="dummy">
                                <li>wrapSync</li>
                            </ul>
                        </dd>
                    </dl>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>func</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p> 同步函数，或者返回 Promise 的函数。用于被转换成一个 <a href="global.html">AsyncFunction </a>.</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>

                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p><code>func</code> 的一个异步包装器。 使用 <code>(args..., callback)</code> 调用。</p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>// 传递一个常规的同步函数
async.waterfall([
    async.apply(fs.readFile, filename, &quot;utf8&quot;),
    async.asyncify(JSON.parse),
    function (data, next) {
        // 数据是解析文本的结果。
        // 如果解析发生错误，这个错误会被捕获。
    }
], callback);

// 传入一个返回 Promise 的函数
async.waterfall([
    async.apply(fs.readFile, filename, &quot;utf8&quot;),
    async.asyncify(function (contents) {
        return db.model.create(contents);
    }),
    function (model, next) {
        // `model` 是实例化的 model 对象。
        // 如果有一个错误，这个函数就会被跳过。
    }
], callback);

// es2017 示例, 如果你的 JS 环境支持开箱即用的 async 函数， 那么不需要 `asyncify`
var q = async.queue(async.asyncify(async function(file) {
    var intermediateStep = await processFile(file);
    return await somePromise(intermediateStep)
}));

q.push(files);</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="asyncify.js.html">asyncify.js</a>, <a href="asyncify.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="constant"><span class="type-signature">(static) </span>constant<span class="signature">()</span><span class="type-signature"> &#x2192; {<a href="global.html">AsyncFunction </a>}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import constant from &apos;async/constant&apos;;</code></pre>
                        <p> 当它被调用时，返回一个函数，使用提供的值进行调用-返回。 对于作为 <a href="#waterfall"><code>waterfall</code></a> 的第一个函数，或者将值插入 <a href="#auto"><code>auto</code></a> 中很有帮助。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>arguments...</code></td>
                                <td class="type">
                                    <span class="param-type">*</span>
                                </td>
                                <td class="description last">
                                    <p>任意数量的参数都将自动调用回调。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>当被调用时返回一个函数，使用之前给定的参数自动调用调用回调。</p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.waterfall([
    async.constant(42),
    function (value, next) {
        // value === 42
    },
    //...
], callback);

async.waterfall([
    async.constant(filename, &quot;utf8&quot;),
    fs.readFile,
    function (fileData, next) {
        //...
    }
    //...
], callback);

async.auto({
    hostname: async.constant(&quot;https://server.net/&quot;),
    port: findFreePort,
    launchServer: [&quot;hostname&quot;, &quot;port&quot;, function (options, cb) {
        startServer(options, cb);
    }],
    //...
}, callback);</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="constant.js.html">constant.js</a>, <a href="constant.js.html#line3">line 3</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="dir"><span class="type-signature">(static) </span>dir<span class="signature">(function)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import dir from &apos;async/dir&apos;;</code></pre>
                        <p>记录一个<a href="global.html"><code>异步</code> 函数</a> 的结果到
                            <code>控制台</code> 使用 <code>console.dir</code> 来显示结果对象的属性。 仅在 Node.js 或者支持 <code>console.dir</code> 和
                            <code>console.error</code> (例如 FF and Chrome) 的浏览器中工作。如果从异步函数返回多个参数，
                            <code>console.dir</code> 会按照顺序调用每一个参数。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>function</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>您希望最终应用所有参数的函数。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>arguments...</code></td>
                                <td class="type">
                                    <span class="param-type">*</span>
                                </td>
                                <td class="description last">
                                    <p>应用于函数的任意数量的参数。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>// 在一个模块中
var hello = function(name, callback) {
    setTimeout(function() {
        callback(null, {hello: name});
    }, 1000);
};

// 在 node 控制台中
node&gt; async.dir(hello, &apos;world&apos;);
{hello: &apos;world&apos;}</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="dir.js.html">dir.js</a>, <a href="dir.js.html#line3">line 3</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="ensureAsync"><span class="type-signature">(static) </span>ensureAsync<span class="signature">(fn)</span><span class="type-signature"> &#x2192; {<a href="global.html">AsyncFunction </a>}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import ensureAsync from &apos;async/ensureAsync&apos;;</code></pre>
                        <p>包裹一个异步函数，并确保它在事件循环的后一轮调用它的回调。 如果函数已经在下一轮（tick）调用了它的回调，没有额外的延迟。 这常被用来防止堆栈溢出 (
                            <code>RangeError: Maximum call stack size exceeded</code>) 和 并且通常保持<a href="http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony">Zalgo</a>的控制是很有用的。 ES2017 <code>async</code> 函数是按原样返回的 -- 他们的对 Zalgo的腐化免疫，因为他们总是在后一轮里解决（resolve）。
                        </p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>fn</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>一个异步函数，它期望 node样式的回调作为它的最后一个参数。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>返回一个包裹函数，它与传入的函数具有完全相同的调用签名。</p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>function sometimesAsync(arg, callback) {
    if (cache[arg]) {
        return callback(null, cache[arg]); // 这将是同步的!!
    } else {
        doSomeIO(arg, callback); // 这个 IO 将是异步的。
    }
}

// 如果将许多结果缓存在行中，则会出现堆栈溢出的风险
async.mapSeries(args, sometimesAsync, done);

// 如果有必要，这将推迟 sometimesAsync 的回调，
// 防止堆栈溢出
async.mapSeries(args, async.ensureAsync(sometimesAsync), done);</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="ensureAsync.js.html">ensureAsync.js</a>, <a href="ensureAsync.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="log"><span class="type-signature">(static) </span>log<span class="signature">(function)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import log from &apos;async/log&apos;;</code></pre>
                        <p>记录一个 <code>async</code> 函数的结果到 <code>控制台</code> 。 仅在 Node.js 或者支持 console.dir 和 console.error (例如 FF and Chrome) 的浏览器中工作。 如果从异步函数返回多个参数， <code>console.log</code> 会按照顺序调用每一个参数。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>function</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>您希望最终应用所有参数的函数。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>arguments...</code></td>
                                <td class="type">
                                    <span class="param-type">*</span>
                                </td>
                                <td class="description last">
                                    <p>应用于函数的任意数量的参数。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>

                    <pre class="prettyprint"><code>// 在一个模块中
var hello = function(name, callback) {
    setTimeout(function() {
        callback(null, &apos;hello &apos; + name);
    }, 1000);
};

// 在 node 控制台
node&gt; async.log(hello, &apos;world&apos;);
&apos;hello world&apos;</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="log.js.html">log.js</a>, <a href="log.js.html#line3">line 3</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="memoize"><span class="type-signature">(static) </span>memoize<span class="signature">(fn, hasher)</span><span class="type-signature"> &#x2192; {<a href="global.html">AsyncFunction </a>}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import memoize from &apos;async/memoize&apos;;</code></pre>
                        <p>缓存一个异步函数的结果。当创建一个哈希来存储函数结果时，从哈希中省略了回调，并且可以使用一个可选的哈希函数。</p>
                        <p>如果没有指定哈希函数，那么第一个参数将被用作哈希键，如果它是一个字符串或数据类型则转换为一个不同的字符串，那么它可能会正常工作。 注意，对象和数组不会有合理的行为。 其他参数是有效的也不行。在这种情况下，指定您自己的哈希函数。
                        </p>
                        <p>结果的缓存是由 <code>memoize</code> 返回的函数的 <code>memo</code> 属性暴露的。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>fn</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>用于代理和缓存结果的异步函数。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>hasher</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>一个可选函数，用于为存储结果生成一个自定义的哈希。除了回调，它还有所有应用于它的参数。 必须是同步的。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p><code>fn</code> 的缓存版本（memoized）</p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>var slow_fn = function(name, callback) {
    // do something
    callback(null, result);
};
var fn = async.memoize(slow_fn);

// fn 现在可以被用作 slow_fn了
fn(&apos;some name&apos;, function() {
    // callback
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="memoize.js.html">memoize.js</a>, <a href="memoize.js.html#line12">line 12</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="nextTick"><span class="type-signature">(static) </span>nextTick<span class="signature">(callback)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import nextTick from &apos;async/nextTick&apos;;</code></pre>
                        <p>在事件循环的下一个循环调用 <code>callback</code> 。 在 Node.js 中，这只需要调用 <code>process.nextTick</code>。 在浏览器中，如果 <code>setImmediate</code> 可用，使用它。 否则使用 <code>setTimeout(callback, 0)</code>, 这意味着其他更高优先级的事件可能会在 <code>callback</code> 执行之前执行。
                        </p>
                        <p>这在内部是用于浏览器兼容性的。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>该函数在事件循环的后面的循环中被调用。使用 (args...) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>args...</code></td>
                                <td class="type">
                                    <span class="param-type">*</span>
                                </td>
                                <td class="description last">
                                    <p>
                                        在下一轮循环中传递给回调的任何数量的附加参数。
                                    </p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>var call_order = [];
async.nextTick(function() {
    call_order.push(&apos;two&apos;);
    // call_order 现在等于 [&apos;one&apos;,&apos;two&apos;]
});
call_order.push(&apos;one&apos;);

async.setImmediate(function (a, b, c) {
    // a, b, 和 c 等于 1, 2, 和 3
}, 1, 2, 3);</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="nextTick.js.html">nextTick.js</a>, <a href="nextTick.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#setImmediate">async.setImmediate</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="reflect"><span class="type-signature">(static) </span>reflect<span class="signature">(fn)</span><span class="type-signature"> &#x2192; {function}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import reflect from &apos;async/reflect&apos;;</code></pre>
                        <p>
                            将异步函数包装在另一个函数中，该函数的结果是一个对象，即使在它出错时也是如此。
                        </p>
                        <p>该结果对象可以是有属性 <code>error</code> 或者 <code>value</code>.</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>fn</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>你想包裹的异步函数。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <ul>
                            <li>返回一个函数，这个函数总是传递 null 给它的回调。回调的第二个参数时一个<code>object</code> ，这个对象有一个 <code>error</code> 或者一个 <code>value</code> 属性。</li>
                        </ul>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type">function</span>
                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>async.parallel([
    async.reflect(function(callback) {
        // do some stuff ...
        callback(null, &apos;one&apos;);
    }),
    async.reflect(function(callback) {
        // do some more stuff but error ...
        callback(&apos;bad stuff happened&apos;);
    }),
    async.reflect(function(callback) {
        // do some more stuff ...
        callback(null, &apos;two&apos;);
    })
],
// optional callback
function(err, results) {
    // values
    // results[0].value = &apos;one&apos;
    // results[1].error = &apos;bad stuff happened&apos;
    // results[2].value = &apos;two&apos;
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="reflect.js.html">reflect.js</a>, <a href="reflect.js.html#line5">line 5</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="reflectAll"><span class="type-signature">(static) </span>reflectAll<span class="signature">(tasks)</span><span class="type-signature"> &#x2192; {Array}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import reflectAll from &apos;async/reflectAll&apos;;</code></pre>
                        <p>一个使用 <code>reflect</code> 来包裹函数数组或对象的助手函数。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>tasks</code></td>
                                <td class="type">
                                    <span class="param-type">Array</span> |
                                    <span class="param-type">Object</span> |
                                    <span class="param-type">Iterable</span>
                                </td>
                                <td class="description last">
                                    <p> 包裹进 <code>async.reflect</code> 的 <a href="global.html">异步函数</a>集合。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>
                            返回一个异步函数数组，每个函数都被包裹进 <code>async.reflect</code></p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type">Array</span>
                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>let tasks = [
    function(callback) {
        setTimeout(function() {
            callback(null, &apos;one&apos;);
        }, 200);
    },
    function(callback) {
        // do some more stuff but error ...
        callback(new Error(&apos;bad stuff happened&apos;));
    },
    function(callback) {
        setTimeout(function() {
            callback(null, &apos;two&apos;);
        }, 100);
    }
];

async.parallel(async.reflectAll(tasks),
// optional callback
function(err, results) {
    // values
    // results[0].value = &apos;one&apos;
    // results[1].error = Error(&apos;bad stuff happened&apos;)
    // results[2].value = &apos;two&apos;
});

// 使用对象的示例
let tasks = {
    one: function(callback) {
        setTimeout(function() {
            callback(null, &apos;one&apos;);
        }, 200);
    },
    two: function(callback) {
        callback(&apos;two&apos;);
    },
    three: function(callback) {
        setTimeout(function() {
            callback(null, &apos;three&apos;);
        }, 100);
    }
};

async.parallel(async.reflectAll(tasks),
// optional callback
function(err, results) {
    // values
    // results.one.value = &apos;one&apos;
    // results.two.error = &apos;two&apos;
    // results.three.value = &apos;three&apos;
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="reflectAll.js.html">reflectAll.js</a>, <a href="reflectAll.js.html#line6">line 6</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#reflect">async.reflect</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="setImmediate"><span class="type-signature">(static) </span>setImmediate<span class="signature">(callback)</span><span class="type-signature"></span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import setImmediate from &apos;async/setImmediate&apos;;</code></pre>
                        <p>在事件循环的之后的循环调用 <code>callback</code>。在 Node.js 中，只需要调用 <code>setImmediate</code>。在浏览器中，如果 <code>setImmediate</code> 可用就使用它。否则，使用 <code>setTimeout(callback, 0)</code>, which means other higher priority events may precede the execution
                            of <code>callback</code>.</p>
                        <p>这在内部是用于浏览器兼容性的。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>callback</code></td>
                                <td class="type">
                                    <span class="param-type">function</span>
                                </td>
                                <td class="description last">
                                    <p>该函数在事件循环的后面的循环中被调用。使用 (args...) 调用。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>args...</code></td>
                                <td class="type">
                                    <span class="param-type">*</span>
                                </td>
                                <td class="description last">
                                    <p>在下一轮循环中传递给回调的任何数量的附加参数。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>var call_order = [];
async.nextTick(function() {
    call_order.push(&apos;two&apos;);
    // call_order 现在等于 [&apos;one&apos;,&apos;two&apos;]
});
call_order.push(&apos;one&apos;);

async.setImmediate(function (a, b, c) {
    // a, b, 和 c 等于 1, 2, 和 3
}, 1, 2, 3);</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="setImmediate.js.html">setImmediate.js</a>, <a href="setImmediate.js.html#line3">line 3</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#nextTick">async.nextTick</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="timeout"><span class="type-signature">(static) </span>timeout<span class="signature">(asyncFn, milliseconds, info<span class="signature-attributes">opt</span>)</span><span class="type-signature"> &#x2192; {<a href="global.html">AsyncFunction </a>}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import timeout from &apos;async/timeout&apos;;</code></pre>
                        <p>设置异步函数的时间限制。如果函数在指定的时间内未调用回调，那么它将使用一个超时错误调用回调。 错误对象的代码属性将是 <code>&apos;ETIMEDOUT&apos;</code>。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>asyncFn</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>收到事件限制的异步函数。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>milliseconds</code></td>
                                <td class="type">
                                    <span class="param-type">number</span>
                                </td>
                                <td class="description last">
                                    <p>指定的时间限制。</p>
                                </td>
                            </tr>
                            <tr>
                                <td class="name"><code>info</code></td>
                                <td class="type">
                                    <span class="param-type">*</span>
                                    <span class="optional">&lt;optional&gt;</span>

                                </td>
                                <td class="description last">
                                    <p>任何想要附加的超时错误对象 Error的变量(<code>string</code>, <code>object</code>, 等等)，以获取更多信息。</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>返回一个包裹函数，可以和任何控制流函数配合使用。就像使用 <code>asyncFunc</code> 的那样，使用与之相同的参数调用这个函数。</p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type"><a href="global.html">AsyncFunction </a></span>

                        </dd>
                    </dl>
                    <h5>Example</h5>
                    <pre class="prettyprint"><code>function myFunction(foo, callback) {
    doAsyncTask(foo, function(err, data) {
        // 处理 errors
        if (err) return callback(err);

        // do some stuff ...

        // 返回处理后的 data
        return callback(null, data);
    });
}

var wrapped = async.timeout(myFunction, 1000);

// 就像调用 `myFunction` 那样调用 `wrapped` 
wrapped({ bar: &apos;bar&apos; }, function(err, data) {
    // 如果 `myFunction` 花费 &lt; 1000 ms的事件来执行，`err`
    // `err`  和 `data` 将包含他们执行后的值

    // 否则 `err` 将是一个 Error，错误代码为  &apos;ETIMEDOUT&apos;
});</code></pre>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="timeout.js.html">timeout.js</a>, <a href="timeout.js.html#line4">line 4</a>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                    <h4 class="name" id="unmemoize"><span class="type-signature">(static) </span>unmemoize<span class="signature">(fn)</span><span class="type-signature"> &#x2192; {<a href="global.html">AsyncFunction </a>}</span></h4>
                    <div class="description">
                        <pre class="prettyprint source"><code>import unmemoize from &apos;async/unmemoize&apos;;</code></pre>
                        <p>撤销函数的 <a href="#memoize">memoize</a> 操作， 恢复为原始的，未缓存的形状。 方便测试。</p>
                    </div>
                    <h5>Parameters:</h5>
                    <table class="params">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th class="last">Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="name"><code>fn</code></td>
                                <td class="type">
                                    <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                                </td>
                                <td class="description last">
                                    <p>缓存化（memoized）的函数</p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5>Returns:</h5>
                    <div class="param-desc">
                        <p>返回一个函数，这个函数调用原始的未缓存化的函数。</p>
                    </div>
                    <dl class="param-type">
                        <dt>Type</dt>
                        <dd>
                            <span class="param-type"><a href="global.html">AsyncFunction </a></span>
                        </dd>
                    </dl>
                    <dl class="details">
                        <dt class="tag-source">Source:</dt>
                        <dd class="tag-source">
                            <ul class="dummy">
                                <li>
                                    <a href="unmemoize.js.html">unmemoize.js</a>, <a href="unmemoize.js.html#line1">line 1</a>
                                </li>
                            </ul>
                        </dd>
                        <dt class="tag-see">See:</dt>
                        <dd class="tag-see">
                            <ul>
                                <li>
                                    <p><a href="#memoize">async.memoize</a></p>
                                </li>
                            </ul>
                        </dd>
                    </dl>
                </article>
            </section>
            <footer>
                Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Dec 10 2017 17:11:38 GMT+0800 (CST) using the Minami theme. Documentation has been modified from the original. For more information, please see
                the <a href="https://github.com/caolan/async">async</a> repository.</footer>
        </div>
    </div>

    <nav id="toc">
        <h3>Methods:</h3>
        <ul class="nav methods">
            <li class="toc-header"><a href="#collections">Collections</a></li>
            <li data-type="method" class="toc-method"><a href="#concat">concat</a></li>
            <li data-type="method" class="toc-method"><a href="#concatLimit">concatLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#concatSeries">concatSeries</a></li>
            <li data-type="method" class="toc-method"><a href="#detect">detect</a></li>
            <li data-type="method" class="toc-method"><a href="#detectLimit">detectLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#detectSeries">detectSeries</a></li>
            <li data-type="method" class="toc-method"><a href="#each">each</a></li>
            <li data-type="method" class="toc-method"><a href="#eachLimit">eachLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#eachOf">eachOf</a></li>
            <li data-type="method" class="toc-method"><a href="#eachOfLimit">eachOfLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#eachOfSeries">eachOfSeries</a></li>
            <li data-type="method" class="toc-method"><a href="#eachSeries">eachSeries</a></li>
            <li data-type="method" class="toc-method"><a href="#every">every</a></li>
            <li data-type="method" class="toc-method"><a href="#everyLimit">everyLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#everySeries">everySeries</a></li>
            <li data-type="method" class="toc-method"><a href="#filter">filter</a></li>
            <li data-type="method" class="toc-method"><a href="#filterLimit">filterLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#filterSeries">filterSeries</a></li>
            <li data-type="method" class="toc-method"><a href="#groupBy">groupBy</a></li>
            <li data-type="method" class="toc-method"><a href="#groupByLimit">groupByLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#groupBySeries">groupBySeries</a></li>
            <li data-type="method" class="toc-method"><a href="#map">map</a></li>
            <li data-type="method" class="toc-method"><a href="#mapLimit">mapLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#mapSeries">mapSeries</a></li>
            <li data-type="method" class="toc-method"><a href="#mapValues">mapValues</a></li>
            <li data-type="method" class="toc-method"><a href="#mapValuesLimit">mapValuesLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#mapValuesSeries">mapValuesSeries</a></li>
            <li data-type="method" class="toc-method"><a href="#reduce">reduce</a></li>
            <li data-type="method" class="toc-method"><a href="#reduceRight">reduceRight</a></li>
            <li data-type="method" class="toc-method"><a href="#reject">reject</a></li>
            <li data-type="method" class="toc-method"><a href="#rejectLimit">rejectLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#rejectSeries">rejectSeries</a></li>
            <li data-type="method" class="toc-method"><a href="#some">some</a></li>
            <li data-type="method" class="toc-method"><a href="#someLimit">someLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#someSeries">someSeries</a></li>
            <li data-type="method" class="toc-method"><a href="#sortBy">sortBy</a></li>
            <li data-type="method" class="toc-method"><a href="#transform">transform</a></li>
            <li class="toc-header"><a href="#controlflow">Control Flow</a></li>
            <li data-type="method" class="toc-method"><a href="#applyEach">applyEach</a></li>
            <li data-type="method" class="toc-method"><a href="#applyEachSeries">applyEachSeries</a></li>
            <li data-type="method" class="toc-method"><a href="#auto">auto</a></li>
            <li data-type="method" class="toc-method"><a href="#autoInject">autoInject</a></li>
            <li data-type="method" class="toc-method"><a href="#cargo">cargo</a></li>
            <li data-type="method" class="toc-method"><a href="#compose">compose</a></li>
            <li data-type="method" class="toc-method"><a href="#doDuring">doDuring</a></li>
            <li data-type="method" class="toc-method"><a href="#doUntil">doUntil</a></li>
            <li data-type="method" class="toc-method"><a href="#doWhilst">doWhilst</a></li>
            <li data-type="method" class="toc-method"><a href="#during">during</a></li>
            <li data-type="method" class="toc-method"><a href="#forever">forever</a></li>
            <li data-type="method" class="toc-method"><a href="#parallel">parallel</a></li>
            <li data-type="method" class="toc-method"><a href="#parallelLimit">parallelLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#priorityQueue">priorityQueue</a></li>
            <li data-type="method" class="toc-method"><a href="#queue">queue</a></li>
            <li data-type="method" class="toc-method"><a href="#race">race</a></li>
            <li data-type="method" class="toc-method"><a href="#retry">retry</a></li>
            <li data-type="method" class="toc-method"><a href="#retryable">retryable</a></li>
            <li data-type="method" class="toc-method"><a href="#seq">seq</a></li>
            <li data-type="method" class="toc-method"><a href="#series">series</a></li>
            <li data-type="method" class="toc-method"><a href="#times">times</a></li>
            <li data-type="method" class="toc-method"><a href="#timesLimit">timesLimit</a></li>
            <li data-type="method" class="toc-method"><a href="#timesSeries">timesSeries</a></li>
            <li data-type="method" class="toc-method"><a href="#tryEach">tryEach</a></li>
            <li data-type="method" class="toc-method"><a href="#until">until</a></li>
            <li data-type="method" class="toc-method"><a href="#waterfall">waterfall</a></li>
            <li data-type="method" class="toc-method"><a href="#whilst">whilst</a></li>
            <li class="toc-header"><a href="#utils">Utils</a></li>
            <li data-type="method" class="toc-method"><a href="#apply">apply</a></li>
            <li data-type="method" class="toc-method"><a href="#asyncify">asyncify</a></li>
            <li data-type="method" class="toc-method"><a href="#constant">constant</a></li>
            <li data-type="method" class="toc-method"><a href="#dir">dir</a></li>
            <li data-type="method" class="toc-method"><a href="#ensureAsync">ensureAsync</a></li>
            <li data-type="method" class="toc-method"><a href="#log">log</a></li>
            <li data-type="method" class="toc-method"><a href="#memoize">memoize</a></li>
            <li data-type="method" class="toc-method"><a href="#nextTick">nextTick</a></li>
            <li data-type="method" class="toc-method"><a href="#reflect">reflect</a></li>
            <li data-type="method" class="toc-method"><a href="#reflectAll">reflectAll</a></li>
            <li data-type="method" class="toc-method"><a href="#setImmediate">setImmediate</a></li>
            <li data-type="method" class="toc-method"><a href="#timeout">timeout</a></li>
            <li data-type="method" class="toc-method"><a href="#unmemoize">unmemoize</a></li>
        </ul>
        <h3>Methods:</h3>
    </nav>
    <br class="clear">
    <script src="https://cdn.jsdelivr.net/prettify/0.1/prettify.js"></script>

    <script src="https://cdn.jsdelivr.net/jquery/2.2.4/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/typeahead.js/0.11.1/typeahead.bundle.min.js"></script>
    <script>
        prettyPrint();